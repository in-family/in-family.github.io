<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[折腾来折腾去]]></title>
  <link href="http://pikipity.github.com/atom.xml" rel="self"/>
  <link href="http://pikipity.github.com/"/>
  <updated>2013-01-30T00:00:00+08:00</updated>
  <id>http://pikipity.github.com/</id>
  <author>
    <name><![CDATA[pikipity]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[利用 Arduino 进行超声波测距]]></title>
    <link href="http://pikipity.github.com/blog/ultrasonic-distance-measurement-using-arduino.html"/>
    <updated>2013-09-21T10:32:00+08:00</updated>
    <id>http://pikipity.github.com/blog/ultrasonic-distance-measurement-using-arduino</id>
    <content type="html"><![CDATA[<p>在<a href="http://pikipity.github.io/blog/arduino-dht11-lcd1602.html">昨天测量温度的装置</a>上又加上了 HC-SR04 来进行超声波测距，先利用 DHT11 测量温度，然后利用温度来计算出较为准确的声速（根据<a href="http://en.wikipedia.org/wiki/Relativistic_Euler_equations">相对论的欧拉方程</a>，声速（米每秒）=331+0.6*温度（摄氏度）），再利用 HC-SR04 测得的超声波来回的时间计算出距离，并在 LCD1602 上显示。</p>

<p>HC-SR04 的使用非常简单，<a href="http://www.doc88.com/p-737494835063.html">这里有一份 HC-SR04 的中文手册</a>，首先向 Trig 引脚输入一个不小于10us的高电平，然后测量 Echo 引脚返回的高电平的时间 t，然后利用公式：距离=t*声速/2，就可以计算得到距离了。但是需要注意：</p>

<ol>
  <li>测量周期要在60ms以上，防止回声影响。</li>
  <li>计算距离时单位要统一，利用<code>pulseIn()</code>函数返回的时间单位是“微秒”，测量结果单位一般是“厘米”，所以声速要从“米每秒”换算为“厘米每微秒”，也就是除以10000。</li>
  <li>测量距离为2cm~400cm，太近的话会有盲区，太远的话由于返回信号太弱难以检测。</li>
</ol>

<p><a href="https://github.com/pikipity/Ultrasonic_distance_measurement_using_Arduino.git">程序可以到这里下载</a>，其中 “HC_SR04_Arduino” 文件夹中是一个 HC-SR04 的 Arduino 测试程序，“display_LCD1602” 文件夹中是这次的程序，”scheme” 文件夹中是电路图。</p>

<p>程序中使用 “Time” 库来实现定时器中断的功能，<a href="http://srmonk.blogspot.com/2012/01/arduino-timer-library.html">“Time” 库可以在这里下载</a>，如果你觉得看英文比较烦得话，可以看<a href="http://yehnan.blogspot.com/2012/03/arduino.html">这里这个中文简易教程</a>。</p>

<p>电路图：</p>

<p><img src="https://lh5.googleusercontent.com/-2ggKDjtrfuY/Uj0D_AibosI/AAAAAAAABMw/4VVXk4M1NiY/s640/Breadboard_bb.png" alt="面包板连接图" /></p>

<p><img src="https://lh3.googleusercontent.com/-P3TPBqNYi1E/Uj0D_AqZCmI/AAAAAAAABMs/KXupBqQvZj8/s576/Breadboard_schem.png" alt="电路图" /></p>

<p>结果（LCD 上，第一行为湿度和温度，第二行为距离）：</p>

<p><img src="https://lh5.googleusercontent.com/-lM53a5xTLsA/Uj0D_fkuoxI/AAAAAAAABM0/eefNICQs9Ys/s512/result.jpg" alt="结果" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Arduino 测量温度和湿度]]></title>
    <link href="http://pikipity.github.com/blog/arduino-dht11-lcd1602.html"/>
    <updated>2013-09-20T22:00:00+08:00</updated>
    <id>http://pikipity.github.com/blog/arduino-dht11-lcd1602</id>
    <content type="html"><![CDATA[<p>今天中秋放假闲在宿舍里，于是就用 Arduino 做了一个测量温度和湿度的小装置，使用 DHT11 测量温度和湿度，然后用 LCD1602 来显示。</p>

<p><a href="http://wenku.baidu.com/view/bb12c7c7d5bbfd0a795673dd.html">这里有一个 DHT11 的简单介绍</a>，包括引脚的意义和解法还有一个 Arduino 的例程。DHT11 的使用还是很简单的，基本思路就是先发送给 DHT11 一个信号，将其激活，成功激活后，DHT11 会返回一个信号，之后 DHT11 就会连续发送40位的二进制数据，这40bits的数据包括湿度数值、温度数值和校检数值，其中湿度数值和温度数值都是16位的定点二进制小数（<a href="http://pikipity.github.io/blog/scm-principle-3.html">定点二进制小数在这里有介绍</a>），其中前8位为整数位，后8位为小数位，具体排列如下：</p>

<pre><code>8位湿度整数位 8位湿度小数位 8位温度整数位 8位温度小数位 8位校检数值
</code></pre>

<p>DHT11 具体操作步骤如下：</p>

<ol>
  <li>发送启动信号：拉低引脚至少18ms，拉高引脚20us到40us</li>
  <li>检测 DHT11 的返回信号：如果可以检测到一个低信号80us，然后一个高信号80us，则启动成功，进入下一步开始接受数据，否则启动失败。</li>
  <li>开始接受数据：低信号时等待下一位数据，高信号时计算高信号的宽度，如果是26us到28us，则此位为“0”，如果是70us，则此位为“1”，共40位。</li>
</ol>

<p>使用 DHT11 要注意的是：</p>

<ol>
  <li>湿度单位为“%RH”（<a href="http://zh.wikipedia.org/wiki/%E7%9B%B8%E5%B0%8D%E6%BF%95%E5%BA%A6">相对湿度</a>），温度单位为“℃”（摄氏度）。</li>
  <li>它的精度并不高，湿度误差为±5%RH，温度为±2℃。</li>
  <li>校检数值使用方法：如果湿度整数位加上温度整数位等于校检数值，那么传输无误，否则存在传输错误。</li>
  <li>采样周期不得小于1秒钟</li>
</ol>

<p>LCD1602 就简单很多了，直接使用 Arduino 自带的 “LiquidCrystal” 库就可以很轻松的进行控制了，库中所包含的函数、使用方法和例程可以到<a href="http://arduino.cc/en/Reference/LiquidCrystal">这里看 “LiquidCrystal” 官方说明文档</a>。</p>

<p>以下是我设计的电路：</p>

<p><img src="https://lh6.googleusercontent.com/-lWe2CscmyLw/Ujv5p3ZbUgI/AAAAAAAABMM/0Dv91ak3_9o/s640/Breadboard_bb.png" alt="面包板连接图" /></p>

<p><img src="https://lh6.googleusercontent.com/-aX-NkrUuHvI/Ujv5piz0TnI/AAAAAAAABMQ/bdtvWYZfm1A/s720/Breadboard_schem.png" alt="电路连接图" /></p>

<p><a href="https://github.com/pikipity/Display_Temp_and_Humi_using_LCD1602.git">程序可以到这里下载</a>。其中 “DHT11_Arduino” 文件夹中是对 DHT11 的测试，用的是串口显示测量结果，“LCD_Arduino” 文件夹中是对 LCD1602 的测试，显示的 “hello World”，“display”  文件夹中是整个的代码，”Sketch” 中是电路图和结果图。</p>

<p>最终结果如下：</p>

<p><img src="https://lh5.googleusercontent.com/-z0G7fuWmDjs/Ujv5pwiav-I/AAAAAAAABMU/OTBrKNvVwxU/s640/result.jpg" alt="结果" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让我们一起来征服世界]]></title>
    <link href="http://pikipity.github.com/blog/introduction-to-terraria.html"/>
    <updated>2013-09-16T20:14:00+08:00</updated>
    <id>http://pikipity.github.com/blog/introduction-to-terraria</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/-xBEV9XTEUq8/UjcIJFQTLzI/AAAAAAAABL0/MzrQc4KU-oU/s364/Logo.png" alt="Terraria" /></p>

<p>今天推荐一款沙盒游戏 – <a href="http://www.terraria.org/">《Terraria》</a>。“沙盒游戏”是模拟游戏的一个分支，玩家在一个大世界下自由行动，通常没有明确的目标，玩家发挥想象自由创造，例如<a href="http://www.ali213.net/zt/spore/">《孢子》</a>、<a href="http://zh.wikipedia.org/wiki/%E4%BF%A0%E7%9B%9C%E7%8D%B5%E8%BB%8A%E6%89%8B%E7%B3%BB%E5%88%97">《侠盗猎车手》</a>、<a href="https://minecraft.net/">《minecraft》</a>都属于沙盒游戏，其中<a href="https://minecraft.net/">《minecraft》</a>的超高的自由度现在应该是无人不知无人不晓了。</p>

<p>如果你知道 <a href="https://minecraft.net/">《minecraft》</a> 的话，<a href="http://www.terraria.org/">《Terraria》</a> 可以理解为 2D 的<a href="https://minecraft.net/">《minecraft》</a>，但是绝对不是等同，从资源到怪物都完全不同，故事背景就更是一点关系都没有了，唯一相同的就是极高的自由度和挖矿的重要性。如果你连 <a href="https://minecraft.net/">《minecraft》</a> 都不知道的话，看一看下面这个视频，如果你觉得发挥想象挖掘世界、创造物品挺有趣的话，那么我就及其推荐你玩一玩这款游戏，你可以充分享受自己发现世界、创造文明的乐趣。当然和 <a href="https://minecraft.net/">《minecraft》</a> 一样，可以联机和小伙伴们一起进行世界探索。</p>

<embed height="452" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://static.hdslb.com/miniloader.swf" flashvars="aid=127992&amp;page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" />

<p>缺点也和 <a href="https://minecraft.net/">《minecraft》</a> 一样，新人入手比较困难，由于完全没有新手指南（NPC 新手向导除了会告诉你配方外还会告诉你一些小贴士，但是等你听完他的小贴士早就黑天了，然后僵尸来了，然后。。。就没然后了），新手可以到<a href="http://www.mcbbs.net/thread-4917-1-1.html">这里</a>看一看，至少可以帮助平安度过第一夜，然后就是你自由的探索了，等你遇到瓶颈的时候，可以到<a href="http://tieba.baidu.com/f?kw=terraria">贴吧</a>看一看，会很有启发的。当你将原版玩到腻了，就可以尝试打各种各样的 MOD，换种玩法继续玩。总之，这是一款一旦入手就不想放手的游戏。</p>

<ul>
  <li>Windows 用户<a href="http://tieba.baidu.com/p/2591750651">这里</a>下载（注意看安装说明，需要安装一些其他的东西）。</li>
  <li>Windows 上的有钱人可以到 <a href="http://store.steampowered.com/app/105600/">Steam</a> 上购买，联机什么的就不是问题了。</li>
  <li>Mac OS X 用户<a href="http://pan.baidu.com/share/link?shareid=1013474534&amp;uk=4080321956">这里</a>下载（原始的 dmg 找不到了就把自己的 app 压缩了一下传上来了，可能连自己的人物和世界一起打包了，将就着用吧，无法联机，需要联机的请用 <a href="http://pikipity.github.io/blog/wine.html">Wine</a>）。</li>
  <li>IOS 用户可以到<a href="https://itunes.apple.com/us/app/id640364616?mt=8">这里</a>下载</li>
  <li>Andriod 用户可以到<a href="https://play.google.com/store/apps/details?id=com.and.games505.Terraria">这里</a>下载</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[processing 练习作 -- 3D 色子]]></title>
    <link href="http://pikipity.github.com/blog/processing-prectice-3d-dice.html"/>
    <updated>2013-09-12T00:24:00+08:00</updated>
    <id>http://pikipity.github.com/blog/processing-prectice-3d-dice</id>
    <content type="html"><![CDATA[<p>processing 的练习作 – 3D 色子，旨在练习 processing 的 3D 效果制作。点击鼠标可以抛掷色子。色子的图案没有使用额外的图片，全部使用 processing 直接绘制。源代码在<a href="https://github.com/pikipity/3D_Dice.git">这里</a>。由于不是专注于正方体自由旋转落体的模拟，左移在色子的运动上做的很简单：上升和下落都是一个匀加速直线运动，每次落地撞击损失一半的速度；旋转方面每次根据坐标轴随机选取一个旋转方向，旋转速度和位移成正比；没有考虑触地之后的运动。</p>

<p><img src="https://lh4.googleusercontent.com/-Qzgu5jWc-zY/UjCcf32YpqI/AAAAAAAABI4/myK3RPH83x8/s512/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-09-12%2520%25E4%25B8%258A%25E5%258D%258812.33.52.png" alt="程序截图" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一本正经的恶搞 -- 伪基百科]]></title>
    <link href="http://pikipity.github.com/blog/introduction-uncyclopedia.html"/>
    <updated>2013-09-10T04:33:00+08:00</updated>
    <id>http://pikipity.github.com/blog/introduction-uncyclopedia</id>
    <content type="html"><![CDATA[<p><img src="https://lh5.googleusercontent.com/-Ths-brV6Q7E/Ui4wdOPGFsI/AAAAAAAABIo/Fed-Tb1wjr4/s152/Uncyclopedia_Logo_China_1.png" alt="适度恶搞，有益身心" /></p>

<p>今天找资料的时候无意间发现了这样一个网站，里面全是无厘头的恶搞，看得我完全刹不住车了，不是没见过恶搞，但是像这样一本正经、诚意满满地恶搞还从来没有见过。这个网站就是 <a href="http://zh.uncyclopedia.info/wiki/%E9%A6%96%E9%A0%81">“伪基百科”</a>。页面从结构到文章形式完全仿照<a href="http://zh.wikipedia.org/">“维基百科”</a>，但是内容则没有一点是正经的，建议18岁以下儿童及身心脆弱者、极度爱党爱国人士不要点击进入。</p>

<p><a href="http://zh.wikipedia.org/wiki/%E5%81%BD%E5%9F%BA%E7%99%BE%E7%A7%91">“维基百科”是这样介绍“伪基百科”的</a>：</p>

<blockquote>
  <p>伪基百科（英语：Uncyclopedia），是一个功能、操作方式与维基百科类似，但主要以恶搞为目的而创建的网站群。虽然号称是百科全书，但实际是一个试图以百科全书形式“搞笑”的网站。 </p>
</blockquote>

<p><a href="http://zh.uncyclopedia.info/wiki/%E7%B6%AD%E5%9F%BA%E7%99%BE%E7%A7%91">“伪基百科”是这样介绍“维基百科”的</a>：</p>

<blockquote>
  <p>維基百科（Wikipedia, the Evil and Useless Fucked-up Free Encyclopedia）是一個抄襲偽基百科架構的擺爛惡毒的垃圾網站，相同於偽基百科採用wiki(偽基)架構，亦堅持所有人皆可參與編輯其內容，在網站名稱上採用近似的發音。致使使用者在辨識上陷入重大錯誤，而不自知。</p>

  <p>不僅內容不盡不實，而且資訊富含錯誤量驚人，致使知名如王爾德者亦無法接受！王爾德因理解維基百科在各種意義上實現唬爛與豪洨本質，憤而投靠偽基百科，並成為偽基之神。維基百科依據所謂的「維基倒亂法」，在一定意義上反轉事實與虛幻的傳統形上學認識，影響後世對實在界的真實理解，誤以虛構作品裡的事物代之，規定真實世界的一切都是人類意識內後天創造出來的假有概念，對人類近代史發展上，極大程度之負面影響。</p>

  <p>相較於偽基百科唯一不同的是，維基百科堅持不有趣路線，所以比較多好人普遍接受這種不有趣，因而沉醉其中。基此諸多因素，維基百科出乎進步史觀上意料的發展成網路上最大的百科全書之一，與另外一個相較之下更形枯燥、味如嚼蠟，近一百年來號稱世界第一的大英百科全書編輯群氣得跳腳，潑婦罵街。維基百科亦因此諸多因素成為全世界第一個被罵是公廁的網站。
基於被給予公廁的意義，維基百科從頭髮一直到腳趾開始武裝起來，進軍先進文明國家，嘗試以無聊KUSO的路線來同化偽基百科與大英百科全書，以各種可能的意義上欺騙大眾，進而實現愚民的目的性，雖然內容全是雜碎，但其數目確實令人望而快慰。
在僅能保持被動的現有條件之下，防範維基百科大軍來襲，外型像一隻陽痿公雞的偽中華人民共和國的迷信馬克思的共匪創造了世界十七大奇境之一－－沒用的防火長城，亦無法阻擋維基百科的入侵，因為維基百科是一個被大陸共匪控制的垃圾百科。直至今日，因為太過枯燥乏味到快要沒命，沒有人要去維基百科，所以上帝便賦予了偽基百科的功能，試圖在知識的黑暗時代中開創一條可行的道路。</p>
</blockquote>

<p>读完上面的你是不是发现自己已经不认识“维基百科”了。 o(╯□╰)o</p>

<p>友情提示：由于两者从网页链接到名称都极为相似，做作业的时候注意不要找错网站啊！囧</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LED 亮度控制 -- processing 练习作]]></title>
    <link href="http://pikipity.github.com/blog/light-controller.html"/>
    <updated>2013-09-08T20:52:00+08:00</updated>
    <id>http://pikipity.github.com/blog/light-controller</id>
    <content type="html"><![CDATA[<p>又是一个自己制作的 processing 的练习作，旨在练习 processing 与 Arduino 的串口通信。使用 Processing 编写的可视化控制条，用户可以通过拉拽控制条来调整亮度的数值，通过串口将亮度输送给 Arduino，由 Arduino 实现 LED 灯亮度的调整。由于是很简单的控制，所以就没有考虑什么保护电阻之类的了，直接很简单将 LED 插在了开发板上。视频中就可以看出，当亮度 100% 的时候（也就是电压达到 5V 的时候），LED 会过亮，可能会损坏 LED。</p>

<p>可以到<a href="https://github.com/pikipity/Light_Controller.git">这里</a>下载源码。</p>

<p>程序截图：</p>

<p><img src="https://lh6.googleusercontent.com/-IHYJhlfZPoc/UixyaVzcbYI/AAAAAAAABIM/jEakPgrxBqA/s800/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-09-08%2520%25E4%25B8%258B%25E5%258D%25888.03.49.png" alt="程序截图" /></p>

<p>硬件连接：</p>

<p><img src="https://lh6.googleusercontent.com/-agA7VbMa52g/UixyanVbgEI/AAAAAAAABIY/kfIqR_7uBRs/s640/%25E7%2585%25A7%25E7%2589%2587%252013-9-8%2520%25E4%25B8%258B%25E5%258D%25888%252001%252036.jpg" alt="硬件连接" /></p>

<p>控制视频（没有任何处理直接传渣浪，果然画质惨不忍睹）：</p>

<div><object id="ssss" width="480" height="370"><param name="allowScriptAccess" value="always" /><embed pluginspage="http://www.macromedia.com/go/getflashplayer" src="http://you.video.sina.com.cn/api/sinawebApi/outplayrefer.php/vid=114236415_3342829334_OBrgGio5CWXK+l1lHz2stqlF+6xCpv2xhGm3v1CsJwdaVgiYJMXNb9wG5CvVBstD9HoLHcwydP8i1R4rbKtd/s.swf" type="application/x-shockwave-flash" name="ssss" allowfullscreen="true" allowscriptaccess="always" width="480" height="370" /></object></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[processing 练习作 -- 小画板]]></title>
    <link href="http://pikipity.github.com/blog/practice-for-processing.html"/>
    <updated>2013-09-05T16:57:00+08:00</updated>
    <id>http://pikipity.github.com/blog/practice-for-processing</id>
    <content type="html"><![CDATA[<p>在<a href="http://pikipity.github.io/blog/new-game-processing.html">这篇文章</a>中我简单介绍了用来编写视觉交互式软件的编程语言 <a href="https://processing.org/">processing</a>，这是我的一个练习作 – 一个简单的小画板，旨在练习 Processing 的基本命令和熟悉 Java 的语法。源代码可以到<a href="https://github.com/pikipity/Drawer.git">这里</a>下载。</p>

<p>左侧选择工具，右侧选择画笔粗细和颜色。按”e”键结束当前工具输入（画直线、方框、圆形和不规则图形时有效）；按”r”键画布清零。</p>

<p>截图：</p>

<p><img src="https://lh6.googleusercontent.com/-CQpds8QLtt8/UihEwkBDmPI/AAAAAAAABH4/SeNgK7VRgr8/s640/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-09-05%2520%25E4%25B8%258B%25E5%258D%25884.43.37.png" alt="界面" /></p>

<p>小问题：</p>

<ol>
  <li>没有保存功能。</li>
  <li>颜色和画笔粗细比较单一。</li>
  <li>在画直线、方框、圆形和不规则图形时没有预览功能，不方便。</li>
</ol>

<p>在编写过程中就会发现 processing 语言在功能上还是有一定的欠缺的，比如不能够抓取一部分界面进行重绘，换句话说就是没有“撤销”功能，但是如果仅仅想编写一个静态的交互界面已经绰绰有余了，无怪乎很多 Arduino 教学网站都推荐这个语言。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[听黑桐谷歌访谈有感]]></title>
    <link href="http://pikipity.github.com/blog/heitongguge.html"/>
    <updated>2013-08-29T09:33:00+08:00</updated>
    <id>http://pikipity.github.com/blog/heitongguge</id>
    <content type="html"><![CDATA[<p>“黑桐谷歌”是出没于优酷和AB站的著名职业游戏解说，今天推荐的是他的一个访谈，访谈本身很业余（毕竟第一期，业余很正常），但是谷歌坦言的自己开始做游戏解说的历史和一路走来的心路历程才是视频的重点内容。</p>

<embed height="452" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://static.hdslb.com/miniloader.swf" flashvars="aid=736273&amp;page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" />

<p>整个过程主要讲了两个话题（我私自将两个话题扩大化）：如何从默默无闻到一呼百应；中国非商业化活动的现状。</p>

<h3 id="section">平民大神</h3>

<p>当我看着视频，听着谷歌大大说着自己做游戏的过程和期间心中所想的时候，我不知不觉想起了以下几个人名（下面几个人都是公认的神级人物，但都离我们很遥远，但是谷歌大大，应该算是平民级的大神，更加贴近我们的生活实际，所以我在这里推荐他的访谈，而不是以下几个人的）：</p>

<ul>
  <li><a href="http://zh.wikipedia.org/wiki/%E7%90%86%E6%9F%A5%E5%BE%B7%C2%B7%E6%96%AF%E6%89%98%E6%9B%BC">理查德·斯托曼</a></li>
  <li><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;sqi=2&amp;ved=0CCoQFjAA&amp;url=http%3A%2F%2Fzh.wikipedia.org%2Fzh-hant%2F%25E5%258F%25B2%25E8%2592%2582%25E5%25A4%25AB%25C2%25B7%25E4%25B9%2594%25E5%25B8%2583%25E6%2596%25AF&amp;ei=R6geUr-kBOfoiAerqYDYCA&amp;usg=AFQjCNFYNdQBHtLgy9nnA5gYJsQoZxglFA&amp;sig2=z8dPt-xkcLHR3B7jpygeFQ&amp;bvm=bv.51495398,d.aGc">史蒂夫·乔布斯</a></li>
  <li><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;sqi=2&amp;ved=0CCoQFjAA&amp;url=http%3A%2F%2Fzh.wikipedia.org%2Fzh-hant%2F%25E6%25AF%2594%25E5%25B0%2594%25C2%25B7%25E7%259B%2596%25E8%258C%25A8&amp;ei=XageUoqlNuTkiAfbnYHYBA&amp;usg=AFQjCNFsmBBPY2jXjFNf4_80u3HXMJT5-g&amp;sig2=2l_1eW8YxA0Yrwy8oT5tfA&amp;bvm=bv.51495398,d.aGc">比尔·盖茨</a></li>
</ul>

<p>回顾它们的创业史，你会发现惊人的相似，它们都具备以下几点：</p>

<ol>
  <li>明确的目标：目标清晰明了，对于自己要做什么、最终结果怎么样，有很准确的定位。还有就是这个目标在自己心中分量必须足够沉重，沉重到即使整个世界都否定了你你还依然能够坚持下去。大多数人即使大学毕业往往还是不知道自己应该做些什么，就算有了目标，当别人否定的时候，也会自己对自己开始质疑，导致徘徊不定，错失良机。</li>
  <li>强大的行动力：不让目标仅仅是个梦想，而是付出自己的努力和心血将其变为现实的行动力是不可或缺的。如果谷歌大大没有前期对市场的考察与研究，没有每个视频背后千百次对游戏的摸索，他也绝对不会像现在这样得到广大粉丝的认可。</li>
  <li>创新力：必要的创新不可或缺，当然我这里所说的创新是对于一个区域甚至世界而言的创新，不是对于个人的创新。谷歌大大逐渐形成的解说风格和其拒绝商业化而采用捐献的方式都是他的创新。</li>
</ol>

<p>以上三点应该是我们每个人最缺乏但是却是成功不可或缺的素质，如果说，高中和上大学都是我们听从父母前辈的建议走的，那么接下来的路怎么走就要靠自己了，别人的经验永远带有个别独立性，别人只能提供方法，我们所能做的只能是借鉴吸收和学习而已。</p>

<h3 id="section-1">中国式咬尾蛇怪圈</h3>

<p>谷歌大大在视频中提到的那个中国游戏视频届的困境，其实也同样是中国开源软硬件的困境。中国人版权意识的淡薄、一味索取不愿付出的习惯必然会导致这样的困境：有的人因为爱好开始做视频（开源软硬件），慢慢地将其变为自己的职业，但为了生计，不得不开始利用自己的爱好寻求经济上的支援，无法得到的情况下只能走上商业化的道路，广告和收费让用户流失，最终放弃。</p>

<p>谷歌大大这种自愿式捐款其实在国外非常常见，很多开源式的软硬件都是使用这种方式来支持自己的生活来实现维护项目的更新，但是在中国这种方式能否走得通还有待进一步的实验，毕竟中国人尤其是中国的电脑和互联网用户已经习惯了只为实体商品付费，而不愿为无形体的商品或是服务付费。这种现状非常不利于开源技术的进步，当所有的科技都被几个大型公司占领的时候，科技发展的速度和前景也就被限制住了，个人的创新也就被限制住了。</p>

<p>但是这种现状的打破需要每个人一点一滴的努力才可以，谷歌大大在微博上放出捐款名单的做法我是很支持的，这种鼓励的方式可以看出还是很有效的。</p>

<p>希望每个人对于这种因爱好而诞生的产物多贡献一点一起努力打破这种中国式怪圈。</p>

<h3 id="section-2">最后</h3>

<p>不要忘了加 <a href="http://weibo.com/pikipitywz">pikipity</a> 和 <a href="http://weibo.com/blackgoogle">黑桐谷歌</a> 的新浪微博呦。<a href="https://me.alipay.com/heitongguge">支持原创，一元也可，有你支持，由黑桐谷歌更新</a></p>

<ul>
  <li><a href="http://space.bilibili.tv/43536">黑桐谷歌 B 站卖萌大厅</a></li>
  <li><a href="http://i.youku.com/u/id_UOTE2MDY5NDg=">黑桐谷歌优酷空间</a></li>
  <li><a href="https://itunes.apple.com/cn/app/you-xi-shi-pin-jie-shuo/id660574550?mt=8">黑桐谷歌视频解说 IOS App</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新玩具 -- Processing]]></title>
    <link href="http://pikipity.github.com/blog/new-game-processing.html"/>
    <updated>2013-08-28T12:37:00+08:00</updated>
    <id>http://pikipity.github.com/blog/new-game-processing</id>
    <content type="html"><![CDATA[<p><img src="https://lh5.googleusercontent.com/-YJlrgUSftcw/Uh2LCQCqpSI/AAAAAAAABHk/BrDYwd8hf_s/s180/180px-Processing_Logo_Clipped.svg.png" alt="Processing" /></p>

<p>在看 Arduino 的资料的时候无意间找到了一个新玩具 – <a href="http://processing.org/">Processing</a>，专门用来开发视觉交互界面用的语言，基础语言是 Java，优点就和他官方网站介绍的一样：</p>

<ul>
  <li>开源，免费下载</li>
  <li>支持多种输出方式，2D、3D 甚至 pdf</li>
  <li>使用 OpenGL 作为 3D 的引擎</li>
  <li>支持多种操作系统，Linux, OSX, Windows</li>
  <li>网络上有众多的扩展库支持</li>
  <li>大量的资料书籍（虽然都是英文的）</li>
</ul>

<p>我的第一反应是把它当做 Pygame 的替代品。相比 Pygame，Processing 的优点众多：</p>

<ul>
  <li>Java 语言本身的优点：Python 蛋疼的内存管理机制和速度问题现在让我越来越烦心了，Java 在这两点上要好得多。</li>
  <li>
    <p>安装方便：Pygame 毕竟是个民间自发的维护项目，更新缓慢，对于刚刚接触 Python 的新手来说安装的过程中就会遇到重重障碍。Processing 的安装则简单的多，而且更新迅速，各个平台的程序都已经打包好了，直接双击安装就可以了，而且自带 IDE（除了自动补全外其他你能想到的、没想到的功能都有了，界面也挺漂亮的），真的是扫除一切学习障碍，诚意满满。</p>

    <p><img src="https://lh5.googleusercontent.com/-m44lymT_wQs/Uh2LCW7aRFI/AAAAAAAABHo/ONQpnwUPbig/s512/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-28%2520%25E4%25B8%258B%25E5%258D%25881.30.05.png" alt="自带 IDE 界面" /></p>
  </li>
  <li>语言更加人性化：Python 的语言已经很人性化了，而 Processing 的语言，尤其是默认变量的命名通过语意猜测就可以知道其代表什么了。命名方式也很统一（Python。。。谁用谁知道，我不吐槽了。）</li>
  <li>事件管理更加轻松：相比 Pygame，Processing 简化了事件管理的部分。不再需要专门再编写代码来获得事件，在 Processing 中鼠标与键盘的事件都变成了一个个默认变量，直接使用这些默认变量就可以获得事件。</li>
  <li>更多扩展库的支持：扩展库不仅数量多而且覆盖的范围很广，使得用 Processing 编写出来的视觉交互界面可以很容易的与其他硬件或软件进行交互，甚至很多特效都已经有库支持，只要直接调用就可以了，非常方便省力。</li>
</ul>

<p>当然，缺点也是有的，其并不适合编写游戏，毕竟此语言是为了开发交互式界面而发明的，对于游戏上的开发乏力还是可以理解的。</p>

<p>总而言之，如果仅仅是想快速开发出一个简单的交互式界面，Processing 绝对是不二人选，但是要开发复杂的交互界面或者游戏的话，还是考虑直接用 Pygame 或是 更加基础的 C 或 C++ 吧。还有因为 Processing 的底层语言是 Java，所以对于我这种用惯了 Python 的人来说，换用 Java 是各种不习惯啊。。。（吐槽：为什么每一句后面都要加个分号啊，为什么还要大括号啊，为什么 for 循环这么麻烦啊。。。）</p>

<p><a href="http://pan.baidu.com/share/link?shareid=1374351361&amp;uk=4080321956">入门教程推荐 – 《爱上 Processing》（专门用了讲解了如何将 Processing 与 Arduino 配合使用）</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[youtube-dl GUI]]></title>
    <link href="http://pikipity.github.com/blog/youtube-dl-gui.html"/>
    <updated>2013-08-25T15:47:00+08:00</updated>
    <id>http://pikipity.github.com/blog/youtube-dl-gui</id>
    <content type="html"><![CDATA[<p>经常在网上看到一些很好的视频想要保存下来，如果保存成书签的形式，每次打开都要重新加载一遍实在是太麻烦了，最好的当然是下载到电脑上，虽然自己找了许多在 Mac OS X 上下载视频的软件，但是其中的广告或是收费升级通知让我烦不胜烦。最后找到了这个软件 – <a href="http://rg3.github.io/youtube-dl/">youtube-dl</a>。用 Python 编写，本来是专门用于下载 YouTube 上的视频的，但是现在支持大部分的视频网站，经测试优酷和土豆都可以正常下载，唯一的缺点就是没有一个 GUI，每次都要打开终端输入一行代码，而且像我这种记忆渣每次都要查一遍它的参数列表，实在麻烦，但是又不忍放弃，于是决定自己为其写一个 GUI。</p>

<p><a href="http://pikipity.github.io/youtube-dl-GUI/">这里是此 youtube-dl GUI 的项目主页</a>，安装及使用方法都可以找到。下面是软件截图，因为仅仅是为了使用方便，所以看上去和简陋，但是功能还是齐全的，下一步希望可以抽时间把 “Options” 做的更人性化一点。</p>

<p><img src="https://lh3.googleusercontent.com/-rkDZUJACtqo/UhmniKahR7I/AAAAAAAABHM/iwtIZ9ZXXuo/s640/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-25%2520%25E4%25B8%258B%25E5%258D%25882.34.08.png" alt="下载中" /></p>

<p><img src="https://lh3.googleusercontent.com/-ZNcrGbCx18M/UhmniTT8BYI/AAAAAAAABHQ/ig4RsA_k8OM/s640/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-25%2520%25E4%25B8%258B%25E5%258D%25882.34.31.png" alt="选择 Options" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tutorialspoint -- Simple Easy Learning]]></title>
    <link href="http://pikipity.github.com/blog/tutorialspoint.html"/>
    <updated>2013-08-23T11:24:00+08:00</updated>
    <id>http://pikipity.github.com/blog/tutorialspoint</id>
    <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/-EOXgioZB97c/UhbZ3vnuTXI/AAAAAAAABG0/cMP-tK0Gn4A/s599/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-23%2520%25E4%25B8%258A%25E5%258D%258811.41.01.png" alt="tutorialspoint -- Simple Easy Learning" /></p>

<p>在网上搜索 JavaScript 教程的时候无意间发现了这个网站 – <a href="http://www.tutorialspoint.com/">tutorialpoint（简称 TP）</a>，整体感觉很像是 <a href="http://www.w3schools.com/">W3School</a>，都是一篇一篇短小精悍并且很实用的教程组成，但是内容更为丰富，不仅包括各式各样的编程语言（例如 Ruby、Python，甚至连 Assembly 都有）还包括一些网络及电脑知识（例如什么是 RSS，什么是云计算等等），编程语言的教程中还带有在线仿真编程器，你可以在其网页上就实践教程中的例子，不用为了安装一个编译器或是为了找一个好用的 IDE 伤破脑筋，先学习，觉得这门语言挺好，可以用，再找编译器或是 IDE 也不迟。</p>

<p>快速浏览了一下其中 Python，Ruby 和 Assembly 的教程，感觉教程很基础很实用，非常适合新手学习，上手快，见效快，基本看完一遍教程，大约就明白这门语言的结构并能变出简单的程序了。总而言之，是个学习电脑、网络、编程知识的好地方。</p>

<p><a href="http://www.tutorialspoint.com/">tutorialpoint（简称 TP）网站传送点</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[尝试两种利用 EMD 来计算瞬时频率的方法]]></title>
    <link href="http://pikipity.github.com/blog/try-two-way-to-find-instaneous-frequency-by-using-emd.html"/>
    <updated>2013-08-19T19:00:00+08:00</updated>
    <id>http://pikipity.github.com/blog/try-two-way-to-find-instaneous-frequency-by-using-emd</id>
    <content type="html"><![CDATA[<p>这两天利用 Matlab 尝试了两种利用 EMD 来计算瞬时频率的方法。EMD 的介绍请看<a href="http://pikipity.github.io/blog/find-a-way-to-calculate-the-instaneous-frequency.html">这里</a>。我利用的是 G. Rilling 的程序计算的 IMF，程序在<a href="http://perso.ens-lyon.fr/patrick.flandrin/emd.html">这里</a>下载。尽管这个程序存在着<a href="http://pikipity.github.io/blog/find-a-way-to-calculate-the-instaneous-frequency.html">这样</a>或<a href="http://pikipity.github.io/blog/find-a-way-to-calculate-the-instaneous-frequency-2.html">那样</a>的问题，但是他利用自己的假设找到了方法来解决，我曾经尝试着利用我在<a href="http://pikipity.github.io/blog/find-a-way-to-calculate-the-instaneous-frequency-2.html">这篇文章</a>中提到的看法来解决那些问题，但是发现，速度大大降低，结果改善却不明显，所以放弃而在这里使用他的程序。</p>

<p>这两种方法中，一种方法先使用 Hilbert Transform 求得 IMF 的瞬时相位，然后利用瞬时相位求得瞬时频率，另一种则不适用 Hilbert Transform，直接根据 IMF 类似弦波这一特性，利用局部极值点与零点来计算瞬时频率。</p>

<!--more-->

<h3 id="section">方法一：瞬时相位求瞬时频率</h3>

<p>关于 Hilber Transform，我在<a href="http://pikipity.github.io/blog/find-a-way-to-calculate-the-instaneous-frequency.html">这篇文章</a>中已经介绍过了，它可以将信号变换为其对应的虚数形式：</p>

<script type="math/tex; mode=display">z(t)=s(t)+j\hat{s}(t)</script>

<p>其中 <script type="math/tex">s(t)</script> 是待分析的 IMF 分量，<script type="math/tex">\hat{s}(t)</script> 是 Hilbert Transform 的结果，利用 Matlab 函数 <code>z=hilbert(s)</code> 可以直接得到 <script type="math/tex">z(t)</script>（注意，得到的是 <script type="math/tex">z(t)</script>，不是 <script type="math/tex">\hat{s}(t)</script>）。由虚数形式我们就可以很轻松地得到瞬时相位 <script type="math/tex">\theta(t)</script> 了。然后利用下式就可以求得瞬时频率了。</p>

<script type="math/tex; mode=display">2\pi f(t)=\omega(t)=\frac{d\theta(t)}{dt}</script>

<p>但是要注意的是，我们只能求得取样点的相位，也就是说，我们求得的相位是离散的，无法求导，这里我使用减法来求近似导数，例如我们要求第 <script type="math/tex">n</script> 个点的瞬时频率，那么就利用下式求得</p>

<script type="math/tex; mode=display">2\pi f(n)=\frac{\theta(n+1)-\theta(n-1)}{2\frac{1}{f_s}}</script>

<p>这里的 <script type="math/tex">f_s</script> 是采样频率。对于数据的第一个点，就将 <script type="math/tex">n-1</script> 改为 <script type="math/tex">n</script>，下面除以一个 <script type="math/tex">\frac{1}{f_s}</script>；对于数据的最后一个点，就将 <script type="math/tex">n+1</script> 换为 <script type="math/tex">n</script>，下面除以一个 <script type="math/tex">\frac{1}{f_s}</script>。Matlab 函数如下，可以在<a href="https://gist.github.com/pikipity/6268454">这里</a>下载。</p>

<pre><code>function [ XPhase,f,Imag,t,f_OGZ,maxf_emdvalue ]=IF_hilbert(x,fs)
%x is the signal that will be analysised
%fs is sample frequency
%XPhase is instanepus phase
%f is instaneous phase
%t is the time string
%f_OGZ is the mean frequency
%maxf_emdvalue is the frequency whose property is maximum.

if length(x)&lt;2
   		error('The length of x is too short')
end
Ts=1/fs;
x=hilbert(x);
XPhase=phase(x);
for n=1:length(x)
	 t(n)=n*Ts;
    Imag(n)=abs(x(n));
    if n==1
        f(n)=1/2/pi*(XPhase(2)-XPhase(1))/Ts;
    elseif n==length(x)
        f(n)=1/2/pi*(XPhase(n)-XPhase(n-1))/Ts;
    else
        f(n)=1/2/pi*(XPhase(n+1)-XPhase(n-1))/2/Ts;
    end
end
f_OGZ=sum(f)/length(f);
f_range=0:1:100;
f_pro=hist(f,f_range);
maxf_emd_pro=max(f_pro);
maxf_emd_pro_index=find(f_pro==maxf_emd_pro);
maxf_emdvalue=f_range(maxf_emd_pro_index);
end
</code></pre>

<p>为了方便以后的对比，我又求了瞬时频率的平均频率<code>f_OGZ</code>和瞬时频率出现概率最高的频率值<code>maxf_emdvalue</code></p>

<h3 id="section-1">方法二：利用极值点与零点来估算瞬时频率</h3>

<p>根据 IMF 的特性，IMF都可以看做多个弦波的叠加，那么对于弦波，一个极值点与零点之间的时间就可以看做四分之一个波长，我们可以根据这个来估算频率，具体推导和理论请看<a href="https://docs.google.com/file/d/0B8AjE9xqZzSiSk1LaFk2akVCT2M/edit?usp=sharing">这篇论文</a>。重点就是利用下面这个公式</p>

<script type="math/tex; mode=display">f=\frac{1}{12}\left\{\frac{1}{T_4}+\left(\frac{1}{T_2^1}+\frac{1}{T_2^2}\right)+\left(\frac{1}{T_1^1}+\frac{1}{T_1^2}+\frac{1}{T_1^3}+\frac{1}{T_1^4}\right)\right\}</script>

<p>或者</p>

<script type="math/tex; mode=display">f=\frac{1}{7}\left\{\frac{1}{4T_4}+\left(\frac{1}{2T_2^1}+\frac{1}{2T_2^2}\right)+\left(\frac{1}{T_1^1}+\frac{1}{T_1^2}+\frac{1}{T_1^3}+\frac{1}{T_1^4}\right)\right\}</script>

<p>符号代表的意思见下图</p>

<p><img src="https://lh3.googleusercontent.com/-y6Y5rCuC4gY/UhIOqdpzm3I/AAAAAAAABD8/62GvEmRK1a8/s512/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-19%2520%25E4%25B8%258B%25E5%258D%25888.24.33.png" alt="上式符号代表的意思" /></p>

<p>很容易发现，这个式子中很注重局部极值点与零点的位置，所以继续使用 G. Rilling 的近似会带来很大的误差，所以，我重新求取了极值点与零点。对于零点，如果利用 G. Rilling 求取的零点位置上信号值不是零，那么在其附近找到一个点，两者的信号值乘积为负数，那么零点必然就在两者中间，作直线，求直线与横坐标的交点作为零点。对于极值点，我在 G. Rilling 的函数找到的极值点的附近再取六个点，利用这七个点的坐标求取一个二次方程 <script type="math/tex">y=ax^2+bx+c</script> 的系数，这个二次方程的极值点作为信号的极值点。Matlab 函数如下，下载在<a href="https://gist.github.com/pikipity/6268692">这里</a>。其中求新的极值点与零点的函数<code>[ newindmin newindmax newindzer ] = refresh_index( x,indmin,indmax,indzer )</code>在<a href="https://gist.github.com/pikipity/6268738">这里</a>。我同样求了一下瞬时频率的平均频率 <code>f_GZC</code>。</p>

<pre><code>function [f,t,f_GZC]=Instaneous_Frequency_Test(x,fs)
% [f,t]=Instaneous_Frequency_Test(x,fs)[f,t]=Instaneous_Frequency_Test(x,fs)
% x is the signal that will be analysised.
% fs is the sampling frequency
% f is the instaneous frquency
% t is the time range of each instaneous frequency
% f_GZC is the mean frequency

%the length of x must be larger than 8
if length(x)&lt;8
    error('the length of x must be larger than 7')
end
%clear results
f=[]; 
t=[];
%calculate sampling periode
Ts=1/fs;
%calculate local extrema and zero
[indmin indmax indzer]=extr(x);
%refresh local extrema and zero
[ newindmin newindmax newindzer ] = refresh_index( x,indmin,indmax,indzer );
indzer=newindzer;
indmin=newindmin;
indmax=newindmax;
%get the index of all indmin, indmax and indzer
%[index,I] = rerange_index( indmin,indmax,indzer );
index=sort([indmin indmax indzer]);
if length(index)&lt;5
    error('Too few extrema and zero')
end
%prepare Begin point index and finish point index
L_index=length(index);
%begin calculate instaneous frquency
Begin_point=4;
Finish_point=L_index-4;
for Number_index=1:L_index-1
    if Number_index==1
        t=[t;index(Number_index) index(Number_index+1)];
        t_q=(index(Number_index+1)-index(Number_index))*Ts;
        t_h_2=(index(Number_index+2)-index(Number_index))*Ts;
        t_f_4=(index(Number_index+4)-index(Number_index))*Ts;
        f=[f 1/3*(1/t_q/4+1/t_h_2/2+1/t_f_4)];
    elseif Number_index==2
        t=[t;index(Number_index) index(Number_index+1)];
        t_q=(index(Number_index+1)-index(Number_index))*Ts;
        t_h_1=(index(Number_index+1)-index(Number_index-1))*Ts;
        t_h_2=(index(Number_index+2)-index(Number_index))*Ts;
        t_f_3=(index(Number_index+3)-index(Number_index-1))*Ts;
        t_f_4=(index(Number_index+4)-index(Number_index))*Ts;
        f=[f 1/5*(1/t_q/4+1/t_h_1/2+1/t_h_2/2+1/t_f_3+1/t_f_4)];
    elseif Number_index==3
        t=[t;index(Number_index) index(Number_index+1)];
        t_q=(index(Number_index+1)-index(Number_index))*Ts;
        t_h_1=(index(Number_index+1)-index(Number_index-1))*Ts;
        t_h_2=(index(Number_index+2)-index(Number_index))*Ts;
        t_f_2=(index(Number_index+2)-index(Number_index-2))*Ts;
        t_f_3=(index(Number_index+3)-index(Number_index-1))*Ts;
        t_f_4=(index(Number_index+4)-index(Number_index))*Ts;
        f=[f 1/6*(1/t_q/4+1/t_h_1/2+1/t_h_2/2+1/t_f_2+1/t_f_3+1/t_f_4)];
    elseif Number_index==L_index-1
        t=[t;index(Number_index) index(Number_index+1)];
        t_q=(index(Number_index+1)-index(Number_index))*Ts;
        t_h_1=(index(Number_index+1)-index(Number_index-1))*Ts;
        t_f_1=(index(Number_index+1)-index(Number_index-3))*Ts;
        f=[f 1/3*(1/t_q/4+1/t_h_1/2+1/t_f_1)];
    elseif Number_index==L_index-2
        t=[t;index(Number_index) index(Number_index+1)];
        t_q=(index(Number_index+1)-index(Number_index))*Ts;
        t_h_1=(index(Number_index+1)-index(Number_index-1))*Ts;
        t_h_2=(index(Number_index+2)-index(Number_index))*Ts;
        t_f_1=(index(Number_index+1)-index(Number_index-3))*Ts;
        t_f_2=(index(Number_index+2)-index(Number_index-2))*Ts;
        f=[f 1/5*(1/t_q/4+1/t_h_1/2+1/t_h_2/2+1/t_f_1+1/t_f_2)];
    elseif Number_index==L_index-3
        t=[t;index(Number_index) index(Number_index+1)];
        t_q=(index(Number_index+1)-index(Number_index))*Ts;
        t_h_1=(index(Number_index+1)-index(Number_index-1))*Ts;
        t_h_2=(index(Number_index+2)-index(Number_index))*Ts;
        t_f_1=(index(Number_index+1)-index(Number_index-3))*Ts;
        t_f_2=(index(Number_index+2)-index(Number_index-2))*Ts;
        t_f_3=(index(Number_index+3)-index(Number_index-1))*Ts;
        f=[f 1/6*(1/t_q/4+1/t_h_1/2+1/t_h_2/2+1/t_f_1+1/t_f_2+1/t_f_3)];
    else
        t=[t;index(Number_index) index(Number_index+1)];
        t_q=(index(Number_index+1)-index(Number_index))*Ts;
        t_h_1=(index(Number_index+1)-index(Number_index-1))*Ts;
        t_h_2=(index(Number_index+2)-index(Number_index))*Ts;
        t_f_1=(index(Number_index+1)-index(Number_index-3))*Ts;
        t_f_2=(index(Number_index+2)-index(Number_index-2))*Ts;
        t_f_3=(index(Number_index+3)-index(Number_index-1))*Ts;
        t_f_4=(index(Number_index+4)-index(Number_index))*Ts;
        f=[f 1/7*(1/t_q/4+1/t_h_1/2+1/t_h_2/2+1/t_f_1+1/t_f_2+1/t_f_3+1/t_f_4)];
    end
end
t=t.*1/fs;
f_GZC=sum(f)/length(f);
end
</code></pre>

<h3 id="fft-">两种方法连同 fft 的比较</h3>

<p>下面来比较一下这两种方法，因为 现在使用最多的还是直接用 fft 来计算频率值，所以这里连同 fft 一起进行比较比较。分析的数据，我是用的是实验室曾经记录的 SSVEP 的信号，数据可以在<a href="http://pan.baidu.com/share/link?shareid=3490016825&amp;uk=4080321956">这里</a>下载，将信号保存到变量<code>x</code>中运行下面这段程序（直接加载入 Matlab 就已经保存在变量<code>x</code>中了），程序在<a href="https://gist.github.com/pikipity/6268877">这里</a>下载</p>

<pre><code>% signal -&gt; x
%begin
fs=600;
Ts=1/fs;
t=1:length(x);
t=(t-1).*Ts;
%figure('name','original signal');plot(t,x)
%IMF=eemd_test(x); %try to use eemd to calculate IOF
IMF=emd(x);
% original signal
figure('name','original signal')
plot(t,x)
xlabel('t (s)')
ylabel('Amplitude')
%IMF components
figure('name','IMF')
for n=1:size(IMF,1)
    subplot(size(IMF,1),1,n)
    plot(t,IMF(n,:))
    xlabel('t (s)')
    ylabel('Amplitude')
    %hold on
    %plot(t,IMF(n,:),'rx')
end
%fft for each IMF components
figure('name','fft')
maxf_fft=[];
for n=2:size(IMF,1)-1
    subplot(size(IMF,1)-2,1,n-1)
    [frequency,fft_result]=fft_plot(IMF(n,:),fs);
    plot(frequency,abs(fft_result(1:length(frequency))))
    xlabel('f (Hz)')
    ylabel('Amplitude')
    axis([0 100 0 max(abs(fft_result(1:length(frequency))))])
    maxf_fft_index=find(abs(fft_result(1:length(frequency)))==max(abs(fft_result(1:length(frequency)))));
    maxf_fftvalue=frequency(maxf_fft_index);
    maxf_fft(n-1)=maxf_fftvalue(1);
end
%IF not using hilbert transform
%IF property
figure('name','IF')
xlabel('frequency')
ylabel('probility (%)')
meanf=[];
maxf_emd=[];
for n=2:size(IMF,1)-1
    subplot(size(IMF,1)-2,1,n-1)
    [f,tf,f_GZC]=Instaneous_Frequency_Test(IMF(n,:),600);
    meanf(n-1)=f_GZC;
    f_range=0:1:100;%frequency range
    f_pro=hist(f,f_range);
    plot(f_range,f_pro./length(f)*100);
    xlabel('frequency')
    ylabel(strcat('IMF',num2str(n),'(%)'))
    maxf_emd_pro=max(f_pro);
    maxf_emd_pro_index=find(f_pro==maxf_emd_pro);
    maxf_emdvalue=f_range(maxf_emd_pro_index);
    maxf_emd(n-1)=maxf_emdvalue(1);
end
%IF in time domain
figure('name','IF value')
for h=2:size(IMF,1)-1
    subplot(size(IMF,1)-2,1,h-1)
    xlabel('t (s)')
    ylabel('f (Hz)')
    [f,tf,f_GZC]=Instaneous_Frequency_Test(IMF(h,:),600);
    hold on
    for n=1:length(f)
        plot([tf(n,1),tf(n,2)],[f(n),f(n)],'k')
        if n~=length(f)
            plot([tf(n,2),tf(n,2)],[f(n+1),f(n)],'k')
        end
    end
end
%IF using hilbert transform
%IF property
figure('name','IF property hilbert')
for n=2:size(IMF,1)-1
    subplot(size(IMF,1)-2,1,n-1)
    xlabel('f (Hz)')
    ylabel('Number')
     [ XPhase,f,Imag,t,f_OGZ,maxf_emdvalue ]=IF_hilbert(IMF(n,:),fs);
     maxf_emd2(n-1)=maxf_emdvalue;
     f_range=0:1:100;%frequency range
    f_pro=hist(f,f_range);
    plot(f_range,f_pro./length(f)*100);
    xlabel('frequency')
    ylabel(strcat('IMF',num2str(n),'(%)'))
end
%IF in time domain
figure('name','IF value hilbert')
for h=2:size(IMF,1)-1
    subplot(size(IMF,1)-2,1,h-1)
    xlabel('t (s)')
    ylabel('f (Hz)')
    [ XPhase,f,Imag,t,f_OGZ,maxf_emdvalue ]=IF_hilbert(IMF(h,:),fs);
    plot(t,f);
end
disp(strcat('frequency in fft from IMF2 to IMF',num2str(size(IMF,1)-1),':'))
disp(maxf_fft)
disp(strcat('frequency in emd not uing heilbert from IMF2 to 	IMF',num2str(size(IMF,1)-1),':'))
disp(maxf_emd)
disp(strcat('frequency in emd using hilbert from IMF2 to 	IMF',num2str(size(IMF,1)-1),':'))
disp(maxf_emd2)
</code></pre>

<p>运行之后会生成多幅图片，对于 15Hz 的信号会得到如下的图片：</p>

<p><img src="https://lh4.googleusercontent.com/-0xZGCMWdvnI/UjLU2NV1mII/AAAAAAAABKk/1UGjM6MJRLU/s720/15-1.jpg" alt="15Hz 原始信号" /></p>

<p><img src="https://lh5.googleusercontent.com/-TwMBSrhpz8M/UjLU2oioM6I/AAAAAAAABKM/gONw6OfgAXA/s800/15-2.jpg" alt="15Hz 各 IMF 分量时域图" /></p>

<p><img src="https://lh6.googleusercontent.com/-GQjdCWO10PE/UjLU24GARmI/AAAAAAAABKQ/ltPy7CnekzY/s800/15-3.jpg" alt="15Hz 各 IMF fft 分析得到的频域图" /></p>

<p><img src="https://lh6.googleusercontent.com/-t2EUbNuPxLU/UjLU3LfTOnI/AAAAAAAABKY/bLHARTXDYOw/s800/15-4.jpg" alt="15Hz 各 IMF 利用方法二得到的各瞬时频率在频域上的分布" /></p>

<p><img src="https://lh4.googleusercontent.com/-6MV4J5HrAJ8/UjLU3mHvOaI/AAAAAAAABKw/w4kLQhfxcxA/s720/15-5.jpg" alt="15Hz 各 IMF 利用方法二得到的个瞬时频率时域分布" /></p>

<p><img src="https://lh5.googleusercontent.com/-xVpy3GU7ZiA/UjLU3gzA3LI/AAAAAAAABKg/vvoYW_h4cbA/s800/15-6.jpg" alt="15Hz 各 IMF 利用方法一得到的各瞬时频率在频域上的分布" /></p>

<p><img src="https://lh5.googleusercontent.com/--CtgNydXY3o/UhIZcbAxgiI/AAAAAAAABFg/4Ymz3vJTATk/s671/6.jpg" alt="15Hz 各 IMF 利用方法一得到的个瞬时频率时域分布" /></p>

<p>对于 10Hz 的信号会得到如下的图片：</p>

<p><img src="https://lh5.googleusercontent.com/-oRJXvkHsb0I/UjLU0L2GLKI/AAAAAAAABJY/xRUbYdyfacA/s800/10-1.jpg" alt="10Hz 原始信号" /></p>

<p><img src="https://lh5.googleusercontent.com/-KM8dafNVOX4/UjLU0YKtv8I/AAAAAAAABJc/D_vIyUT4Bao/s720/10-2.jpg" alt="10Hz 各 IMF 分量时域图" /></p>

<p><img src="https://lh6.googleusercontent.com/--FjsjtAdygg/UjLU0K2zjcI/AAAAAAAABJQ/KlNVWsKeRFk/s800/10-3.jpg" alt="10Hz 各 IMF fft 分析得到的频域图" /></p>

<p><img src="https://lh6.googleusercontent.com/-N06vYTktp2I/UjLU04xcZXI/AAAAAAAABJg/WNO1VMYZnpo/s720/10-4.jpg" alt="10Hz 各 IMF 利用方法二得到的各瞬时频率在频域上的分布" /></p>

<p><img src="https://lh3.googleusercontent.com/-PS9f7lRs24Q/UjLU1AtAIYI/AAAAAAAABJ8/Ceu9qIzU3vE/s720/10-5.jpg" alt="10Hz 各 IMF 利用方法二得到的个瞬时频率时域分布" /></p>

<p><img src="https://lh4.googleusercontent.com/-oF2ANnl2h1w/UjLU1UAksFI/AAAAAAAABJs/Jd5kqOl4gMM/s640/10-6.jpg" alt="10Hz 各 IMF 利用方法一得到的各瞬时频率在频域上的分布" /></p>

<p><img src="https://lh6.googleusercontent.com/-jQR7RJxZhwE/UhIZcNFP4_I/AAAAAAAABFU/xX1crLsefx8/s559/6-2.jpg" alt="10Hz 各 IMF 利用方法一得到的个瞬时频率时域分布" /></p>

<p>在对于数据特征提取的时候，对于 fft，我们直接找频域图（就是第二幅图）上的最大值所对应的频率就是信号的频率，而对于方法一和方法二，我们对于所有瞬时频率进行统计（就是第三和第五幅图，我这里是从1到100，以1为单位进行统计，也就是统计瞬时频率为0.5~1.5的点数，然后统计瞬时频率为1.5~2.5的点数，以此类推），范围内点数最多的频率就是此信号的频率。所以每个频率下的六幅图中，我们重点关注第二、第三和第五幅图，会发现上面两种方法的结果的区别并不明显，并且显然 fft 的结果比上面两种方法的结果还明显。再看一下程序输出的结果，对于15Hz，fft显示频率为14.9414Hz，方法一的结果为13Hz，方法二的结果为13Hz。对于10Hz，fft显示的频率为9.9606Hz，方法一为10Hz，方法二为10Hz。很显然，方法一二在15Hz的时候变得极为不准确。再看图，会发现15Hz的时候方法一得到的瞬时频率时域图（第六幅图）竟然出现了负频，但是 IMF 应该是不存在负频的，而且边缘出现突变，说明算法并不完美，还需要解决这两个问题，而且应该尝试更多的数据并缩短时间（现在我使用的是全部的6秒钟数据）来看看结果如何。</p>

<p>最后总结一下，尽管尝试了两种方法，但是和论文上看到的结果相去甚远，下一步需要：</p>

<ol>
  <li>
    <p>解决两个已发现问题：</p>

    <ul>
      <li>15Hz的时候方法一得到的瞬时频率时域图出现负频的问题</li>
      <li>瞬时频率时域图边缘突变</li>
    </ul>
  </li>
  <li>
    <p>缩短时间看结果</p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[寻找一种有效估算瞬时频率的方法（EMD 求法讨论 续）]]></title>
    <link href="http://pikipity.github.com/blog/find-a-way-to-calculate-the-instaneous-frequency-2.html"/>
    <updated>2013-08-14T03:19:00+08:00</updated>
    <id>http://pikipity.github.com/blog/find-a-way-to-calculate-the-instaneous-frequency-2</id>
    <content type="html"><![CDATA[<p>上接<a href="http://pikipity.github.io/blog/find-a-way-to-calculate-the-instaneous-frequency.html">寻找一种有效估算瞬时频率的方法</a>。</p>

<h3 id="hkt--imf">如何判断 <script type="math/tex">h_k(t)</script> 是 IMF</h3>

<p>黄锷院士提供了两种判断方法：</p>

<ol>
  <li>
    <p>根据 IMF 的定义：</p>

    <ol>
      <li>在整个信号上，局部极值（包括局部极大值和局部极小值）的个数和零点的个数必须等于或最多只能相差一个。</li>
      <li>在任意一点，局部极大值所形成的上包络线和局部极小值所形成的下包络线的平均值等于0</li>
    </ol>

    <p>在这个定义中涉及局部极值问题，也就是我们将讨论的第三个问题，所以我们这里暂且假定我们可以通过一种方法找到局部极值，那么条件的第一点就可以解决了，但是这里要注意，条件的第一点并不能等价于“所有局部极大值都大于0并且所有极小值都小于0”，尽管通过论文中的论述会很容易认为黄锷院士的本意是这样，但是仅仅根据这条论述，会出现很多特殊情况，下面举几个特殊情况的例子，如图</p>

    <p><img src="https://lh6.googleusercontent.com/-7HQOCNGo3cE/UgqLD89QF7I/AAAAAAAABCs/8flUGmA5sT4/s559/1.png" alt="一个局部极小值在零以上或是一个局部极大值在零以下" /></p>

    <p><img src="https://lh5.googleusercontent.com/-mCwygyF6gUY/UgqLD0CDH5I/AAAAAAAABC0/g5aOdQH99T4/s559/2.png" alt="刚好一个局部极值是零点" /></p>

    <p><img src="https://lh5.googleusercontent.com/-6cLysf5vzQA/UgqLDzAvxpI/AAAAAAAABCo/wDF11u8mCGM/s559/3.png" alt="刚好两个局部极值是零点" /></p>

    <p>在 G. Rilling 编写的 MATLAB 程序中，其使用的是这种方法判断的 IMF，有的时候的确会出现上面列出的三种特殊情况，但是既然是按照定义来的，那么应该也没有什么问题，况且对结果也没有大的影响。</p>

    <p>对于条件的第二点则比较困难，即使我们通过三次样条差值找到了包络线，但是我们能够求的也只是插值之后线上的取样点，所以我们只能通过取样点估算上下包络线的平均值，所以这里写为“约等于”0更为合适。</p>
  </li>
  <li>
    <p>黄锷原始在论文中提到另外一种更为简单的判断方式 – 计算 SD 值：</p>

    <table>
      <tbody>
        <tr>
          <td>$$SD_k=\frac{\sum_{t=0}^T \left</td>
          <td>h_{k-1}(t)-h_k(t) \right</td>
          <td>^2}{\sum<em>{t=0}^T h</em>{k-1}^2 (t)}$$</td>
        </tr>
      </tbody>
    </table>

    <p>然后预设一个范围，如果 SD 在此范围内，那么就是 IMF，否则不是。同时，黄锷院士指出 SD 值一般在0.2~0.3之间，但是我看到的大多数程序都是以0.3为界进行判断，小于0.3就是 IMF，大于0.3就不是。Github 上的那个程序就是如此判断的，这样判断的好处是简化了计算过程，使判断变得极为简单，坏处也是显而易见的，SD 的阀值设置的不同导致最终结果就不一样，这和 Wavelet Transform 中选取小波种类类似，阀值的选择反而增大了分析的难度。简化计算难度，增大阀值选择难度，我认为不可取，所以如果能找到一种很好的办法选择出恰当的局部极值点，我认为还是第一种判断方法比较好。</p>
  </li>
</ol>

<h3 id="section">局部极值点与零点的判断</h3>

<p>由于将来计算瞬时频率需要用到零点，所以这里我又加入了零点的判断。局部极值点与零点判断困难是因为我们需要通过有限的原始信号采样点来估计出原始信号，由于采样带来的信息缺失导致困难很大，但是因为我们不需要估计出整个信号，我们只需要估计出原始信号的局部极值与零点就可以了，如果假定采样信号的极值点“约等于”原始信号的极值点，那么我们就面临多个很容易遇到的问题，总结起来列在这里：</p>

<ol>
  <li>采样点中出现连续的极值点与零点如何处理？</li>
  <li>采样点刚好错过极值点与零点如何处理？</li>
  <li>边界点如何处理？</li>
</ol>

<p>在 G. Rilling 的程序中，他取了连续极值点或零点的中间的那个采样点来作为极值点与零点。如果原始信号是一个类正弦信号，这的确是一种好的近似方法，但是对于方波，这种近似方法显然就不合适了。而 Github 上的那个程序，完全没有考虑这个问题。</p>

<p>对于采样点刚好错过极值点与零点的情况，也就是零点或极值点在两个点之间的情况，G. Rilling 的程序只考虑了零点的情况，他将前一个点作为零点的近似，如果采样频率足够大，这的确可以，但是如果采样频率不够大，很显然这样会带来很大的误差。</p>

<p>对于边界点，G. Rilling 根据已有的采样点将边界沿拓，这样边界点就不再是边界点了。在 Github 上的程序则是很简单的将两个边界点直接加入到局部极大值与局部极小值的序列中去。边界沿拓虽然很好，但是复杂并且存在沿拓方法选择的问题。将边界点直接加入虽然简单，但是可能会导致求出的 IMF 边缘震荡，导致分解出无限个 IMF。所以两种方法各有优劣。</p>

<h2 id="section-1">我的想法</h2>

<p>其实总结起来就是两个大问题：</p>

<ol>
  <li>用局部极值求出的上下包络线会出现与原信号相交的问题，这怎么办？</li>
  <li>如何通过离散信号求出原信号的局部极值与零点？</li>
</ol>

<p>而第二个大问题主要就是上面提到的三个特殊情况：</p>

<ol>
  <li>采样点中出现连续的极值点与零点如何处理？</li>
  <li>采样点刚好错过极值点与零点如何处理？</li>
  <li>边界点如何处理？</li>
</ol>

<p>对于的第二个大问题，我认为可以使用原始信号与以求出的上下包络线的切点来修正上下包络线以此来得到不会与原始信号相交的包络线。</p>

<p>对于采样点中出现连续的极值点与零点，我认为可以全部用来计算包络线，无依据，仅仅是感觉，而且由于脑电几乎不会出现方波的状况，所以我认为 G. Rilling 的解决方法已经可以了。</p>

<p>对于采样点刚好错过极值点与零点的情况，如果是零点，我们可以通过两点确定的直线，估算出零点的位置。对于极值点，可以通过再多取几个点做插值，来估算极值点的位置。</p>

<p>对于边界点，我认为还是沿拓比较好，但是沿拓的方法还有待考虑。</p>

<p>但是如果根据我上面提到的方法修改 G. Rilling 的程序，必然带来一个很严重的情况，就是处理时间的延长。收集数据时间变短，但是处理时间变长，致使总时间几乎不改变甚至变长，这完全没有达到我们开始希望的结果嘛，所以 EMD 求法有待讨论与寻找。我认为，如果可以找到一种快速有效解决上述问题的方法，寻找瞬时频率并不是问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐一款游戏 Cube Slam]]></title>
    <link href="http://pikipity.github.com/blog/cube-slam.html"/>
    <updated>2013-08-13T00:01:00+08:00</updated>
    <id>http://pikipity.github.com/blog/cube-slam</id>
    <content type="html"><![CDATA[<p><img src="https://lh4.googleusercontent.com/-idNKKzH2b_0/UgkIm7DLEPI/AAAAAAAABCI/XOPh1qkCafI/s800/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-13%2520%25E4%25B8%258A%25E5%258D%258812.03.25.png" alt="Cube Slam" /></p>

<p>今天推荐一款游戏 – <a href="https://www.cubeslam.com">Cube Slam</a>，这款游戏来自于 <a href="http://www.chromeexperiments.com/">Chrome Experiment</a>，只可以使用 <a href="https://www.google.com/intl/zh-CN/chrome/browser/">Chrome 浏览器</a>才可以打开。这款游戏很简单，就是通过移动面前的挡板来阻挡滑块打中自己，开始会有一层保护膜保护自己，当保护膜被击中一次之后就消失了，场上还会随机出现各式各样的道具，比如加长你的挡板、场上出现大雾或是挡板发射假滑块干扰对方等等。这个游戏不仅可以和电脑（那只熊）对战，也可以邀请其他人对战，当你进入游戏的时候会随机分配一个地址给你，你只要把你的地址发送给对方你们两人就可以开始对抗了（我应该常在<a href="https://www.cubeslam.com/bdysis">这里</a>，来找我玩啊 :-D）。</p>

<p>这款游戏不是基于 Flash 制作的（现在好像已经没有多少网页游戏还固守于 Flash 了吧），前段使用 WebGL 和 three.js 搭建产生出3D效果，后端用 Go 语言编写，这个游戏搭建在 Google APP 云端，所以不会在你的电脑上留下许许多多不必要的垃圾文件，同时实现速度流畅。你甚至可以直接打开 Chrome 中的“开发者工具”来浏览源码。更多有关游戏的技术，可以到<a href="https://www.cubeslam.com/tech">这里</a>看一看。</p>

<p><img src="https://lh4.googleusercontent.com/-tgaNnaaGBG8/UgkIm77nS9I/AAAAAAAABCQ/RU1JxWdidQo/s800/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-13%2520%25E4%25B8%258A%25E5%258D%258812.03.32.png" alt="操作说明" /></p>

<p><img src="https://lh6.googleusercontent.com/-2u8g95xSROQ/UgkInHfMuVI/AAAAAAAABCM/rCY_e3GAzJk/s800/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-13%2520%25E4%25B8%258A%25E5%258D%258812.03.48.png" alt="与“熊”对战" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[机器人机甲是如何炼成的]]></title>
    <link href="http://pikipity.github.com/blog/how-to-make-a-giant-robot-mech-youtube-geek-week.html"/>
    <updated>2013-08-11T18:49:00+08:00</updated>
    <id>http://pikipity.github.com/blog/how-to-make-a-giant-robot-mech-youtube-geek-week</id>
    <content type="html"><![CDATA[<p>我一直认为，一个正真的项目并不是只用一个专业的知识就可以完成的。如果可以把一个成熟的项目称为一个生命体的话，那么完成这个项目的人就应该称为这个项目的上帝了吧，所以，仅仅考一个专业的知识是无法完成的。这就体现了合作的重要性，每个人专精于自己的所长，努力完成自己工作的同时，将自己的所知所学与他人分享，并从他人那里汲取知识，然后多人的智慧融会贯通逐渐将一个项目从无到有，最终将其推向完美，这才是我们需要的。我认为“澳门大学”的科技学院现在需要的正式这种多专业合作的感觉，不是每个专业，甚至每个专业里面的各个小分支都各自顾各自，而应该尝试将各个专业的长处进行融合，使科技学院形成一个整体来运作。数学专业为各个专业做理论基础；机电专精机械，打造成品主构架；电机专精电子，为项目嵌入电子的控制芯片；软件专精程序撰写，为芯片写入可以使其运作的程序。这样各司其职，互相学习，互相进步，比强迫每个专业都要乱七八糟的什么都学强多了。</p>

<p>这个视频是 YouTube 在 Geek Week 时发起的一个项目，目的是制作一个巨大的机器人机甲，整个视频关键的不是技术，因为没有什么新颖的科技，甚至有些都是已经市场化的技术，关键的是其中那种各个专业、各个领域的人们团结一致，合作完成项目的那种氛围。我第一次看的时候我就决定一定要搬运这个专题，要让更多的人感觉到这种感觉。</p>

<p>YouTube 视频地址在<a href="http://www.youtube.com/channel/UCftwRNsjfRo08xYE31tkiyw">这里</a>。国内的话，我搬运到了 bilibili 上，画质降低了，是没办法啊，上传渣浪也只能这样了，地址在<a href="http://www.bilibili.tv/video/av702285/">这里</a>。下面是第一个视频，一个此项目的总体介绍，喜欢的话还是去 <a href="http://www.bilibili.tv/video/av702285/">bilibili</a> 看全部吧。高清视频在<a href="http://pan.baidu.com/share/link?shareid=2919109282&amp;uk=4080321956">这里</a>下载</p>

<embed height="452" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://static.hdslb.com/miniloader.swf" flashvars="aid=702285&amp;page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[寻找一种有效估算瞬时频率的方法（EMD 求法讨论）]]></title>
    <link href="http://pikipity.github.com/blog/find-a-way-to-calculate-the-instaneous-frequency.html"/>
    <updated>2013-08-09T18:50:00+08:00</updated>
    <id>http://pikipity.github.com/blog/find-a-way-to-calculate-the-instaneous-frequency</id>
    <content type="html"><![CDATA[<p>我试图寻找一种可以用比较少的数据点就可以较为精确的估算某个时刻瞬时频率的方法，当然了，根据“薛定尔的胖次”（对于虐猫狂人薛定谔不熟悉的可以去看<a href="https://docs.google.com/file/d/0B8AjE9xqZzSiNlVlSEkxNi1uTFE/edit?usp=sharing">这里</a>的这本少儿读本，写的很好）在信号分析中的拓展，如果要精确计算瞬时频率就需要一个在时域上无限长的信号，当然这是不可能的，所以，如果能够找到一种计算方法，在时域上的精度和频域上的精度问题上去的平衡就可以了。</p>

<p>在经过一番大搜索之后，发现现在最为流行的求瞬时频率的方法就是 HHT（希尔伯特-黄转换，也就是 EMD，经验模态分析，论文在<a href="https://docs.google.com/file/d/0B8AjE9xqZzSiUDhGRkJ3UEwzNjQ/edit?usp=sharing">这里</a>，洋洋洒洒90多页，大家慢慢看）。</p>

<h2 id="section">什么是瞬时频率</h2>

<p>第一个问题我就说不清楚，一般来说，把瞬时频率定义为</p>

<script type="math/tex; mode=display">f(t)=\frac{1}{2\pi}\frac{d\theta(t)}{dt}</script>

<p>这个定义是 Cohen 提出的，但是这个定义仅限于 “monocomponent function”，但是什么是 “monocomponent function” 呢？他没说。。。（坑爹啊 (╯‵□′)╯︵┻━┻）但是 Gabor， Bedrosian 和 Boashash 提出：</p>

<blockquote>
  <p>for any function to have a meaningful instantaneous frequency, the real part of its Fourier transform has to have only positive frequency.</p>
</blockquote>

<p>黄锷院士（就是这个 HHT 的创始人啦）进一步验证得到，对于平均值为零的局部对称信号而言，上述定义的瞬时频率才具有物理意义。</p>

<p>据说，“澳门大学”（请注意，这里不是做宣传）的钱涛教授在提出 AFD 的时候定义了更为准确的瞬时频率，但是博主愚钝，到现在也没看懂他的论文，甚至都不知道从何看起，所以更不用提他提出的方法和定义了。</p>

<h2 id="section-1">寻找新方法的原因</h2>

<p>在寻找到 HHT 之前，手头已经有的方法大体可以分为两种 – Fourier Transform 和 Wavelet Transform，当然还包括一些 Fourier Transform 的变种，例如 Wigner–Ville Distribution。但是这两种方法都存在着各种各样的缺点。</p>

<h3 id="fourier-transform">Fourier Transform</h3>

<p>我们都知道，Fourier Transform 是试图将一个信号分解为多个幅值和频率固定的三角函数线，对于其对于信号的要求是稳定、收敛，但是实际中，尤其是在脑电中，我们无法保证自己截取的信号就是符合要求的。而且 Fourier Transform 所求的是一种平均频率分布，这意味其会带来两大缺点：</p>

<ol>
  <li>能量分散到了整个频谱上，难以辨清具体频率所在。</li>
  <li>产生了无意义的负频。</li>
</ol>

<p>当然，以上两点都可以接受的话，其最致命的缺点就是 <strong>丧失了时间信息</strong>。尽管 STFT (Short Time Fourier Transform) 利用窗截取某个时间段的信号，可以在一定程度上获得瞬间频率，但是由于窗长度一旦选取就固定不变，导致时间精度固定，从而导致频率精度也固定，这样对频率的突变就及其不敏感，而检测突变则是信号分析中非常重要的，所以 Fourier Transform 难以分析瞬时频率。</p>

<h3 id="wavelet-transform">Wavelet Transform</h3>

<p>根据下面 Wavelet Transform 的公式，我们可以清楚的看出，为了改善 Fourier Transform 会丧失时间信息的缺点，Wavelet Transform 添加两个参数 $b$（时间刻度）和 $a$（频率刻度，可以转化为对应的频率），这样就可以同时获得时间和频率两方面的信息。同时，不再使用三角函数作为基函数，而是使用小波 $\phi$ 作为基函数，可以解决 Fourier Transform 用稳定信号分析不稳定信号的问题。</p>

<script type="math/tex; mode=display">W(a,b;W,\phi)=\frac{1}{\sqrt{a}}\int_{-\infty}^{\infty}W(t)\phi^*(\frac{t-b}{a})dt</script>

<p>但其对 Fourier Transform 的改善还是存在缺点：</p>

<ol>
  <li>尽管随着 $a$ 的变化，频率可以在多分辨度下进行解析，但是在某一个分辨度下，其分辨精度还是固定不变的。</li>
  <li>小波一旦选定就无法改变，没有办法保证此小波在整个波段上都合适。</li>
  <li>小波选择问题难以解决，一般只不过是通过经验来进行选择。</li>
</ol>

<h2 id="hht">HHT</h2>

<p>就算上面两种方法可以完美解析实际信号，但是也很难从他们的算法中找到计算瞬时频率的办法，那么根据提到的定义，要找瞬时频率，就要先找瞬时相位，于是慢慢征程刚开始啊。。。</p>

<h3 id="ht">HT</h3>

<p>Gabor 提出一种定义信号相位的方法，如果能够把信号表示成为其对应的复数形式（如下），那么相位自然也就找到了。</p>

<script type="math/tex; mode=display">z(t)=s(t)+j\hat{s}(t)</script>

<p>上式中的 $\hat{s}(t)$ 可以通过 Hilbert Transform (HT) 来得到。下式就是 HT 的转化方法。</p>

<script type="math/tex; mode=display">\hat{s}(t)=\frac{1}{\pi}\int_{-\infty}^{\infty}\frac{s(t)}{t-\tau}d\tau</script>

<p>为了使信号可以进行 HT，并且具有有意义的瞬时频率，必须先对信号进行处理，于是黄锷院士提出 HHT。</p>

<h3 id="imf">IMF</h3>

<p>所谓对信号进行处理，就是将信号拆分为多个可以进行 HT 来寻找瞬时频率的信号 – Intrinsic Mode Function（IMF）。IMF 满足一下两点：</p>

<ol>
  <li>在整个信号上，局部极值（包括局部极大值和局部极小值）的个数和零点的个数必须等于或最多只能相差一个。</li>
  <li>在任意一点，局部极大值所形成的上包络线和局部极小值所形成的下包络线的平均值等于0</li>
</ol>

<p>这个由原始信号到 IMF 的分解流程称为 Empirical Mode Decomposition (EMD)。</p>

<h3 id="emd">EMD</h3>

<p>EMD 的流程非常明确，在上面提供的论文中都有写，待分析的信号为 $s(t)$：</p>

<ol>
  <li>找出 $s(t)$ 的所有局部极大值和局部极小值，接着利用三次样条插值得到由局部极大值连接形成的上包络线和局部极小值连接形成的下包络线。</li>
  <li>求出上下包络线的平均值 <script type="math/tex">m_1(t)</script></li>
  <li>
    <p>利用下式得到第一分量：</p>

<script type="math/tex; mode=display">h_1(t)=s(t)-m_1(t)</script>
  </li>
  <li>
    <p>检查 <script type="math/tex">h_1(t)</script> 是否是 IMF，如果不是则将 <script type="math/tex">h_1(t)</script> 作为原信号返回第一步，直到 <script type="math/tex">h_k(t)</script> 是 IMF，就得到了一个 IMF 分量 <script type="math/tex">c_1(t)</script>，也就是</p>

<script type="math/tex; mode=display">c_1(t)=h_k(t)</script>
  </li>
  <li>
    <p>求剩余分量：</p>

<script type="math/tex; mode=display">r_1(t)=s(t)-c_1(t)</script>
  </li>
  <li>将 $r_1(t)$ 当做新资料，返回步骤1，直到 $r_n(t)$ 为单调函数完成分解。</li>
</ol>

<p>完成分解后，就将原始信号分解为了 $n$ 个 IMF 和一个趋势函数，也就是</p>

<script type="math/tex; mode=display">s(t)=\sum_{k=1}^nc_k(t)+r_n(t)</script>

<h2 id="emd--matlab-">EMD 的 MATLAB 实现</h2>

<p>尽管上面的算法流程第一次看起来清晰明了，但是要注意，我们分析的是离散的数据点，而不是连续的信号，于是这就带来了很多问题，以至于上面流程中很多名词都没有严格的定义，需要我们自己来在编写程序的时候来定义，根据定义的不同，程序最后运行的结果也就会不同。一边考虑我们要分析的信号是离散信号，一边在看一遍上面的流程就会很容易发现下面几个问题：</p>

<ol>
  <li><strong>如何定义离散信号的局部极大值与局部极小值？</strong>因为我们的离散信号是通过实际信号采样得来的，那么就会出现离散信号的局部极值与原始实际信号的局部极值不一样的情况，甚至出现多个连续一样的局部极值，处理起来非常麻烦；而且在考虑局部极值的时候还会出现边缘问题，<strong>离散信号最开始与最末尾的两个点如何处理？</strong>绝对不能舍弃，因为在上面的流程中计算局部极值是会在循环中多次出现，如果每次舍弃两个点，会丢失大量数据，而处理不当，在插值的时候边缘会产生出奇怪的震荡导致 IMF 计算不准确影响瞬时频率估计。</li>
  <li><strong>三次样条插值如何用 MATLAB 实现？</strong>这应该是最容易解决的问题了，因为 MATLAB 中有现成的函数，随后介绍。</li>
  <li><strong>如何判断 $h_k(t)$ 是 IMF？</strong>这个问题应该是第二简单的问题了，随后介绍。</li>
</ol>

<p>以上三个问题的解决方式不同，分解出的 IMF 也就不同，估算得到的瞬时频率的准确度也就不同，我找了多个程序，并自己编写了一个程序，但是效果都不能说是很好，其实还是蛮失望的，EMD 这个方法出现也有很多年了，结果连一个现成的比较完美的 MATLAB 程序都没有。这里使用国际比较认可的由一个法国人 G. Rilling 编写的程序（可以在<a href="http://perso.ens-lyon.fr/patrick.flandrin/emd.html">这里</a>下载到）和我在 Github 上找到的一个效果速度也还可以的 MATLAB 程序（可以在<a href="https://github.com/daochenghaike/EMD.git">这里</a>下载到）综合说明一下他们对上面三个问题的解决方法和我的一些见解。（我写的程序在<a href="https://github.com/pikipity/EMD-using-MATLAB.git">这里</a>，但是仅仅当做错误教程看一看就可以了，方法极度不可取，速度慢不说，分解出来的本应完全正交的 IMF 的频域还会出现重叠，边缘也出现了震荡，导致出现了很多低频杂波。）</p>

<p>由于上面三个问题难易程度不一，我会先讨论第二个问题，然后是第三个，最后再讨论第一个。</p>

<h3 id="matlab-">如何用 MATLAB 实现三次样条差值</h3>

<p>在 MATLAB 中有三种方法可以实现三次样条差值：</p>

<ol>
  <li>
    <p><code>yy=spline(x,y,xx)</code>：我从 Github 上找到的那个程序使用的是这种插值方式。其中，<code>x</code>是断点的横坐标，<code>y</code>是断点的纵坐标，<code>xx</code>是插值之后重新构成的函数采样点的横坐标，<code>yy</code>是插值之后重新构成的函数采样点的纵坐标。当然，你也可以使用 <code>pp=spline(x,y)</code>，这样得到的<code>pp</code>是插值之后的到的函数的 structure，然后可以通过 <code>yy=ppval(pp,xx)</code> 来得到重新构成的函数的采样点。插值效果如图</p>

    <p><img src="https://lh6.googleusercontent.com/-DNSR-F6UQw0/UgY0P9GUX7I/AAAAAAAABBk/L_rerjnTI2k/s912/1.jpg" alt="使用```spline```进行插值" /></p>
  </li>
  <li>
    <p><code>pp=csape(x,y,CONDS)</code>：在我的程序中，这个函数的特点是你可以通过改变<code>CONDS</code>来使用不同的计算三系样条插值的方法，这些方法唯一的不同就是使用的 boundary condition 不一样，根据你选择的方法的不同，你可能需要多提供边界的一次导数或是二次导数作为额外的 boundary condition 来进行计算。其他的参数和第一个方法一样。效果如图</p>

    <p><img src="https://lh4.googleusercontent.com/-LRaMxf6QZdo/UgY0PzPmmTI/AAAAAAAABBs/isBKeOjLf28/s912/2.jpg" alt="使用```csape```进行插值" /></p>
  </li>
  <li>
    <p><code>yy=interp1(x,y,xx,'spline')</code>：这个方法的本质还是调用第一个方法中的函数进行运算，所以其实可以合并到方法一中。G. Rilling 使用的这种方法。</p>
  </li>
</ol>

<p>将上面两种方法进行比较，得到下面这幅图</p>

<p><img src="https://lh3.googleusercontent.com/-qJl5fKw60o8/UgY0P55hX5I/AAAAAAAABBw/x55p0wIhqyI/s912/3.jpg" alt="```spline```和```csape```插值效果比较" /></p>

<p>我们可以发现，只有边界处出现细微差别，其他完全一样，如果调整<code>csape</code>的插值方法，可以得到完全一样的结果，所以使用哪种的效果是完全一样的。</p>

<p>要注意我们用 MATLAB 做三次样条差值是为了寻找上下包络线，那么什么是包络线呢？维基上的解释是这样的</p>

<blockquote>
  <p>在几何学，某个曲线族的包络线（Envelope），是跟该曲线族的每条线都有至少一点相切的一条曲线。（曲线族即一些曲线的无穷集，它们有一些特定的关系。）</p>
</blockquote>

<p>不知道你看懂没有，反正我是没有看懂（囧）。但是我至少看懂了一点，包络线不能和曲线族相交们仅仅是相切，但是用局部极值点三次样条差值得到的包络线有的时候会出现与原信号相切的情况，<a href="http://blog.sina.com.cn/s/blog_6ad0d3de01016two.html">这里</a>提供了一种用切点求包络线的方法，但是据博主说，计算用时会大大增加，EMD 的计算用时本来就很长，如果再让求包络线拖慢时间我认为并不值得，况且出现相切的状况只在局部斜率变化缓慢时出现，脑电上很少出现这种状况，所以我认为用极值点插值已经足够了。</p>

<p>然后是是否使用更高次的插值方式，很多论文中提到使用更高次的插值方式使得到的包络线更加平滑，但是我认为完全没有必要，三次样条插值已经足以满足平滑上的需求，而且我们将来使用的也只不过是插值的到的取样点，过好的平滑反而有可能会被取样点的疏松掩盖掉，三次样条差值足以。</p>

<p>（未完待续）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Geek IQ Test]]></title>
    <link href="http://pikipity.github.com/blog/youtube-geek-week.html"/>
    <updated>2013-08-06T22:53:00+08:00</updated>
    <id>http://pikipity.github.com/blog/youtube-geek-week</id>
    <content type="html"><![CDATA[<p>Youtube 上的 Geek Week 专题即将结束了（8月4号到10号），你去看上面各种各样视频了么？完全就是一场 Geek 盛宴的感觉，从动漫到最新科技，还是很爽的。专题页面在<a href="http://www.youtube.com/user/YouTube/featured">这里</a>。当然，Youtube 那群“疯子”们怎么可能放过这样一个炫耀自己技术，彩蛋自然不能少，具体是什么，请看<a href="http://www.guao.hk/posts/youtubes-geek-week-easter-egg.html">这里</a>。</p>

<p>当然，如果你想看 Geek Week 的详细介绍，随便在 Google 上搜索一下就能得到一大堆的结果，毕竟是“宅”们的节日，网络上怎么能没有介绍。这里要介绍的是 Youtube 上一个很有意思的 “Geek IQ Test”，就是测试一下，你到底有多宅！</p>

<p>游戏规则很简单，每次8道题目，每道题目3个选项，根据视频内容，选择选项，最后根据你答题情况评分。测试在<a href="https://geekweek-live.appspot.com/desktop-us">这里</a>。第一次，题目都是我会的，8道全对，得分如下</p>

<p><img src="https://lh5.googleusercontent.com/-r-YqbpwnVGA/UgES2SzaqRI/AAAAAAAAA9E/MzWceydp9W4/s512/YouTube%2520Spotlight%2520Presents%2520Geek%2520Week%2520-%2520YouTube.jpg" alt="我的 Geek IQ Test 的第一次得分" /></p>

<p>但是后来又试了几次，发现第一次完全是运气好，有几道还是很有难度的，甚至有的即使会，但是英文你也许就不知道怎么说了。多试几次就会发现，题目就是那么几道，下面发一下答案，没做之前不许偷看欧！！！</p>

<!--more-->

<p><br /></p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<p><br /></p>

<p><img src="https://lh4.googleusercontent.com/-CVGWY-Ez2W8/UgES26gfzzI/AAAAAAAAA9I/1p6OFYqb9SE/s769/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.07.15.png" alt="龙珠经典镜头！！答案是 9001" /></p>

<p><img src="https://lh5.googleusercontent.com/-6KVmhjF-3iY/UgES2o-lrZI/AAAAAAAAA9A/t9Mfw09Edis/s770/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.07.20.png" alt="很明显，磁悬浮啦。答案是 Magnetic" /></p>

<p><img src="https://lh4.googleusercontent.com/-aKuL7CrWVw4/UgES3cU9GxI/AAAAAAAAA9U/okwJriD4gu8/s766/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.07.26.png" alt="钻石=煤球 囧 答案是 Carbon" /></p>

<p><a href="http://dragonage.wikia.com/wiki/Tallis"><img src="https://lh3.googleusercontent.com/-JQGmujYuiSg/UgES3ogfZoI/AAAAAAAAA9c/hxh3VRi0RMY/s768/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.07.31.png" alt="我的第一反应是劳拉，仔细看看，衣服怎么有袖子，劳拉性感小背心呢？这个真心不知道，查了一下，答案是 Tallis，是《龙腾世纪》中的一个人物，点图片看官网介绍" /></a></p>

<p><img src="https://lh6.googleusercontent.com/-QrfljyGPxEY/UgES33zpQxI/AAAAAAAAA9k/0JreNQ_HnSk/s762/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.07.38.png" alt="没啥说的，答案是 Double slit" /></p>

<p><img src="https://lh6.googleusercontent.com/-OtkDiEwEb0o/UgES4dKz7xI/AAAAAAAAA9s/JbCF49lgFxg/s768/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.07.42.png" alt="这是啥？？但是能让水看起来是这样的也只能是 Stroboscopic" /></p>

<p><img src="https://lh4.googleusercontent.com/-mfnigwuOEJM/UgES41bff2I/AAAAAAAAA90/YbL3HlVKbRY/s766/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.07.49.png" alt="第一反应是找刺客 Assassin，但是发现三个都是人名！！这。。。前两代主角名字早就忘了好不好啊，第三代虽然各种意义上的“烂尾”，但是人名还是记得，于是选了 Connor，结果对了！" /></p>

<p><a href="http://www.bbc.co.uk/doctorwho/s4/characters/"><img src="https://lh3.googleusercontent.com/-ErpYY4QX04o/UgES5KkhyOI/AAAAAAAAA-E/xP68u57zr-Y/s770/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.07.53.png" alt="别问我这是什么，我不看连续剧。点图片看答案" /></a></p>

<p><img src="https://lh4.googleusercontent.com/-B7VoQQIBdkE/UgES5SmVemI/AAAAAAAAA-A/Ewx43eJLozA/s768/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.08.08.png" alt="好像和气体有关的神奇的事情都和 Bernoulli 有点关系" /></p>

<p><img src="https://lh4.googleusercontent.com/-Nbbc9rldk_g/UgES51vHVyI/AAAAAAAAA-I/1zG3eiGj6XQ/s770/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.08.13.png" alt="突然间想起了掉进洞里的熊" /></p>

<p><img src="https://lh5.googleusercontent.com/-R1NHuAbLa2s/UgES6KVznmI/AAAAAAAAA-U/RhZcelRR5RQ/s770/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.08.19.png" alt="别告诉我你不知道木星用英语怎么说，人家又没让你选这个。答案是 Largest" /></p>

<p><img src="https://lh4.googleusercontent.com/-Ub7ZUhdltOI/UgES6a69RBI/AAAAAAAAA-Y/U1aqcrN8JGM/s766/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.08.30.png" alt="完全没有槽点，Vitruvian 你怎么看？" /></p>

<p><img src="https://lh6.googleusercontent.com/-OEYg0P4SP6s/UgES6pzuotI/AAAAAAAAA-s/KjhDiiOfv6o/s768/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.08.34.png" alt="0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946，………………  费波那西数列" /></p>

<p><img src="https://lh4.googleusercontent.com/-KozCqGmQwB0/UgES7W6Z2kI/AAAAAAAAA-k/8QRFHLzM5MA/s772/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.08.40.png" alt="你连这个都认不出来你还敢做这个测试？" /></p>

<p><img src="https://lh3.googleusercontent.com/-SyiDdwb3Qag/UgES7QkAT6I/AAAAAAAAA-w/CBrVX4rLbJ8/s768/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.08.47.png" alt="#FF0000 更加没槽点了" /></p>

<p><img src="https://lh5.googleusercontent.com/--GcZGbKaGyI/UgES8WS6T1I/AAAAAAAAA_A/CM_sPEoO5h8/s769/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.08.55.png" alt="Inertia 连续没槽点，怎么办啊" /></p>

<p><img src="https://lh4.googleusercontent.com/-o5JV-4AGfz8/UgES8i9cAlI/AAAAAAAAA_I/tUgq9NYh0c4/s768/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.08.59.png" alt="后脑勺上印条形码的大光头，全世界也就一个吧! -- 杀手代号47" /></p>

<p><img src="https://lh3.googleusercontent.com/-m0ghkNOyBh8/UgES8xR68BI/AAAAAAAAA_E/kUjbJNKI2OY/s768/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.09.05.png" alt="Hydrogen 继续无槽点" /></p>

<p><img src="https://lh3.googleusercontent.com/-99stG95-p9w/UgES9egglYI/AAAAAAAAA_U/GZel8XyiyYI/s769/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.36.29.png" alt="Piranha plant? Pirhanna plant!" /></p>

<p><a href="http://en.wikipedia.org/wiki/PAX6"><img src="https://lh5.googleusercontent.com/-l0vv-oydoJ8/UgES93OM25I/AAAAAAAAA_Y/k1mmtqG-Z7I/s770/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258810.37.20.png" alt="FRZ4 我记得是跟视力有关的 DNA，点击图片去维基（全英文，我没看，不知道我记忆中对不对，看了的告诉我）" /></a></p>

<p><img src="https://lh4.googleusercontent.com/-p84keqCckj8/UgEZmQtlBJI/AAAAAAAAA_o/Qy_tkCvyPsc/s766/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-06%2520%25E4%25B8%258B%25E5%258D%258811.41.41.png" alt="一只黑猫孤独的背影，当然是薛定谔的胖次了（如果是白猫你想到了什么？化物语？）" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非常抱歉]]></title>
    <link href="http://pikipity.github.com/blog/i-am-sorry.html"/>
    <updated>2013-08-06T16:00:00+08:00</updated>
    <id>http://pikipity.github.com/blog/i-am-sorry</id>
    <content type="html"><![CDATA[<p>由于 Gmail 把“多说”的新评论通知邮件当做垃圾邮件处理了，以至于今天久违的打开“多说”想看一看的时候，我和我的小博客都吓呆了，这么多评论没有及时回复，这可怎么办啊~~~~~~~</p>

<p>非常抱歉，但是从今天起，评论我都会尽量及时回复的（毕竟网络不是到处都有，但是只要有网就一定会第一时间回复）。谢谢所有看官大老爷的支持，非常感谢，还请以后多多赏脸到小站来看一看，pikipity 也会继续把自己看到的学会的好玩的东西贴出来。</p>

<p>再次说声“对不起”，谢谢大家。</p>

<p><img src="https://lh5.googleusercontent.com/-q5QK9ylkI_o/UgC0S4FpZAI/AAAAAAAAA8o/-cVE-PYlIdQ/s352/I-Am-Sorry.gif" alt="I am sorry" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Alfred 快速启动 MATLAB]]></title>
    <link href="http://pikipity.github.com/blog/open-matlab-fast-using-alfred.html"/>
    <updated>2013-08-05T18:44:00+08:00</updated>
    <id>http://pikipity.github.com/blog/open-matlab-fast-using-alfred</id>
    <content type="html"><![CDATA[<p>大概很多人都会难以忍受 MATLAB 启动时候漫长的等待，那是因为 MATLAB 的窗口化是基于 java 的，加载 java 永远是一个让人蛋疼的事情。但是如果你使用的是 Linux 或是 Mac OS X，那么你完全没必要把时间都花费在等待 MATLAB 准备和打开 java 的过程上。我们真正使用 MATLAB 是使用它的命令行，而它的图形化界面，除了修改图片和使用具有 GUI 的 toolbox，一般很少用到，所以到用到的时候在加载 java 就可以了，而且由于加载 java 和启用命令行的操作分开了，同时运行的线程和占用的内存都减少了，java 的加载速度也会相应提升。总而言之，就是让你觉得 Matlab 快了很多很多。</p>

<p><img src="https://lh3.googleusercontent.com/-IPC7qvN44iA/Uf-RDQ06AZI/AAAAAAAAA8E/oyQ6i78YWwo/s800/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-05%2520%25E4%25B8%258B%25E5%258D%25887.46.50.png" alt="终端使用 MATLAB" /></p>

<p>这里使用的技巧并不高深，只是让 <a href="http://www.alfredapp.com/">Alfred</a> 执行一段 shell 命令，并为这个命令定制关键词，方便以后用 <a href="http://www.alfredapp.com/">Alfred</a> 搜索。</p>

<p><a href="http://www.alfredapp.com/">Alfred</a> 是 Mac OS X 上的一款快速启动、查询工具，类似于 Mac OS X 自带的 spotlight，但是功能上则强大很多。spotlight仅能查询文件并快速打开，<a href="http://www.alfredapp.com/">Alfred</a> 则不仅如此，查询网页、查询词典、替代计算器、查询 iTunes、执行指定 shell 命令、workflow 或是 AppleScript 等等，而且这些功能全部集成到一个搜索条中，超级方便快捷。现在，spotlight 早已经被我禁用了，完全由 <a href="http://www.alfredapp.com/">Alfred</a> 代替。<a href="http://www.alfredapp.com/">Alfred</a> 的官网在<a href="http://www.alfredapp.com/">这里</a>，你可以免费下载和使用，但是免费版中部分功能被限制，用起来还是很不爽的，你可以通过购买获得 Powerpack 激活码，然后就可以享用 <a href="http://www.alfredapp.com/">Alfred</a> 所有强大的功能了。如果你不想付钱，你可以到<a href="http://pan.baidu.com/share/link?shareid=2139275050&amp;uk=4080321956">这里</a>下载 <em>X解程序</em>，但是 v1 旧版的X解程序，官网提供的新版 v2 的X解还请自行 <a href="https://www.google.com">Google</a> 之。</p>

<p><img src="https://lh5.googleusercontent.com/-M187kHThsnM/Uf-RDKTJYBI/AAAAAAAAA8A/QMe45cbl_gI/s512/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-05%2520%25E4%25B8%258B%25E5%258D%25887.00.51.png" alt="Alfred 使用画面" /></p>

<p>这里就不介绍软解的安装与X解还有基本配置了，毕竟软件很简单，一目了然。直奔主题，如何让其执行一段 shell 命令来在终端下打开 MATLAB。</p>

<p>首先，你要知道如何在终端下打开 MATLAB。找到你电脑上的 MATLAB 程序，我指的不是那个 app 在哪，而是在那个 app 上右键，点击显示包内容之后，找到一个文件名叫 matlab 的程序（我记得应该就是一个 shell 脚本），记录下它的路径（右键单击“拷贝路径”中的“Path”，例如我的路径就是<code>/Applications/MATLAB/MATLAB_R2011a.app/bin/matlab</code>）。然后你只要在终端中直接执行这个路径，MATLAB 就会打开了。但是你会发现，依然是以图形化界面的方式打开，所以你需要在路径后面加一些启动参数，常用的启动参数如下</p>

<pre><code>-nodesktop  不启动图形化界面
-nosplash   无欢迎信息
</code></pre>

<p>你也可以在后面使用参数<code>-r</code>，这样，MATLAB打开后就会自动执行后面的命令（需要执行的命令空一格用引号引起来放在后面就可以了，例如<code>-r "x=1:10;plot(x)"</code>）。</p>

<p>现在就要将这个启动 MATLAB 的 shell 命令添加入 <a href="http://www.alfredapp.com/">Alfred</a> 中。打开 <a href="http://www.alfredapp.com/">Alfred</a> 的 “Preferences”，在 “Extensions” 中添加一个 shell 命令，名字随便起一个就好了。”Title” 是你将会在 <a href="http://www.alfredapp.com/">Alfred</a> 中搜索看到的名字，起一个好认的就可以了。”Description” 是你将在 <a href="http://www.alfredapp.com/">Alfred</a> 中显示在名字下面的小字，简单注释一下就可以了。”Keyword” 一定要使用，不然每次打名字就太累了，这里可以设置快捷键，以后搜索的时候打入这个关键字就可以了。”Options” 中的 “Silent” 必须取消掉，不然 MATLAB 会在后台启动而不显示。”Command” 就不多说了，把你要执行的命令放进来就可以了。”Parameter” 是设置你将来搜索的时候是否需要参数，”Auto Detect” 就可以了。保存，就可以使用了。</p>

<p><img src="https://lh4.googleusercontent.com/-DWMROP6I7qA/Uf-RC77dmCI/AAAAAAAAA74/4XxBwboOPjA/s640/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-05%2520%25E4%25B8%258B%25E5%258D%25886.59.51.png" alt="设置画面" /></p>

<p>如果，你觉得设置很麻烦，可以下载我已经设置好的文件，但是要注意把 “matlab” 的路径改为自己电脑上的路径。第一个文件就是简单的在终端打开 MATLAB，但是它还会打开 “workspace” 并清空终端（因为我唯一需要的窗口就是 “workspace”，用来看一下当前保存了哪些变量，当然你也可以用<code>CommandHistory</code>打开命令历史记录）。第二个文件是在终端打开 MATLAB，并执行你输入的一条命令，例如你在 <a href="http://www.alfredapp.com/">Alfred</a> 中输入 <code>matlab "a=5;"</code>，就会打开 MATLAB 之后创建一个变量<code>a</code>。</p>

<ul>
  <li><a href="http://pan.baidu.com/share/link?shareid=2246469849&amp;uk=4080321956">Matlab Terminal</a></li>
  <li><a href="http://pan.baidu.com/share/link?shareid=2452208514&amp;uk=4080321956">Matlab Command</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推荐两个网站]]></title>
    <link href="http://pikipity.github.com/blog/interesting-websites.html"/>
    <updated>2013-08-02T18:31:00+08:00</updated>
    <id>http://pikipity.github.com/blog/interesting-websites</id>
    <content type="html"><![CDATA[<p>今天推荐两个网站：<a href="http://www.yeeyan.org/">译言</a> 和 <a href="http://boinc.berkeley.edu/">BOINC</a></p>

<h3 id="httpwwwyeeyanorg"><a href="http://www.yeeyan.org/">译言</a></h3>

<p>你可以把这个网站当做一个开放的翻译平台，从这里，你可以看别人的译文，也可以自己上传译文，内容则完全没有限制，从新闻政治到漫画小说无所不有。如果你对自己的翻译功底有信心还可以参加到集体翻译的活动中，来和其他用户一起翻译一些经典名作，翻译结束以后，你就可以在书店买到自己翻译的书了，当然是有稿费的。</p>

<p>维基上的介绍更加全面，请点<a href="http://zh.wikipedia.org/wiki/%E8%AF%91%E8%A8%80">这里</a>。译言网站在<a href="http://www.yeeyan.org/">这里</a></p>

<p><img src="https://lh4.googleusercontent.com/-rP32MzQ0NGU/UfuSC3A9kAI/AAAAAAAAA7k/Wce9ankYxhA/s512/%25E8%25AF%2591%25E8%25A8%2580%25E7%25BD%2591%2520-%2520%25E9%25A6%2596%25E9%25A1%25B5.png" alt="译言网首页" /></p>

<h3 id="boinchttpboincberkeleyedu"><a href="http://boinc.berkeley.edu/">BOINC</a></h3>

<p>BOINC 确切来说并不是一个网站，这里给出的是它的wiki。BOINC 其实是一个软件，是一个开放式计算平台。如果你是个强迫症患者，看着自家电脑或是单片机上的 CPU 或是 GPU 的运行率仅仅只有 5% 而感到不爽，那么我极力推荐你安装这款软件。众所周知，一些科学研究需要的计算量非常之大，一个人或者一个实验室的电脑可能完全不够用，于是就可以借助这种分布式计算平台，将志愿者的网络和研究者的网络连接，这样你的电脑也就加入到了计算的行列中来了。</p>

<p>安装软件之后，选择希望参加的项目，然后就可以开始了，软件会自动向你的电脑分配计算任务，任务开始后，你就会心喜的发现，你的 CPU 或是 GPU 的使用率瞬间飙升到 100%（太好了，妈妈再也不用担心我的 CPU 闲置了！）。</p>

<p>项目种类多种多样，从数学到生物医学应有尽有。如果你第一次选择项目，完全不知道要选什么，可以试试最古老的 <a href="http://www.equn.com/wiki/SETI@home">SETI@home</a> 来利用你的电脑寻找外星人。</p>

<p>维基上的介绍在<a href="http://zh.wikipedia.org/wiki/BOINC">这里</a>，官方wiki在<a href="http://boinc.berkeley.edu/">这里</a>，如果你觉得看英文太累，可以到<a href="http://www.equn.com/wiki/BOINC">这里</a>看中国分站的页面。</p>

<p><img src="https://lh4.googleusercontent.com/-HI2o79FTVV8/UfuR-qzubSI/AAAAAAAAA7c/eeYEYtgb1Tc/s512/%25E5%25B1%258F%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7%25202013-08-02%2520%25E4%25B8%258B%25E5%258D%25887.02.36.png" alt="BOINC 支持的项目" /></p>

]]></content>
  </entry>
  
</feed>
